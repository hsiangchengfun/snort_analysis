        -:    0:Source:src/dfc/dfc.c
        -:    0:Graph:./src/dfc/dfc.gcno
        -:    0:Data:./src/dfc/dfc.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:/*********************************/
        -:    2:/* Author  - Byungkwon Choi      */
        -:    3:/* Contact - cbkbrad@kaist.ac.kr */
        -:    4:/*********************************/
        -:    5:
        -:    6:#include "dfc/dfc.h"
        -:    7:
        -:    8:/*************************************************************************************/
        -:    9:#define INIT_HASH_SIZE 65536
        -:   10:#define RECURSIVE_BOUNDARY 5
        -:   11:/*************************************************************************************/
        -:   12:
        -:   13:/*************************************************************************************/
        -:   14:#define PRINT_INFO
        -:   15:#define CT8_SWITCH
        -:   16:
        -:   17:#define ENABLE_PROGRESSIVE_FILTERING
        -:   18:#define ENABLE_RECURSIVE
        -:   19:
        -:   20:#define COUNT_MATCH
        -:   21:/*************************************************************************************/
        -:   22:
        -:   23:/*************************************************************************************/
        -:   24:static unsigned char xlatcase[256];
        -:   25:
        -:   26:/* For extracting position */
        -:   27:int pattern_interval;
        -:   28:int min_pattern_interval;
        -:   29:
        -:   30:static int dfc_total_memory = 0;
        -:   31:static int dfc_pattern_memory = 0;
        -:   32:static int dfc_memory_dfs = (sizeof(uint8_t) * DF_SIZE_REAL) * 14;
        -:   33:static int dfc_memory_ct1 = 0;
        -:   34:static int dfc_memory_ct2 = 0;
        -:   35:static int dfc_memory_ct3 = 0;
        -:   36:static int dfc_memory_ct4 = 0;
        -:   37:static int dfc_memory_ct8 = 0;
        -:   38:/*************************************************************************************/
        -:   39:
        -:   40:/*************************************************************************************/
        -:   41:static float my_sqrtf(float input, float x);
        -:   42:static void init_xlatcase();
        -:   43:static inline void ConvertCaseEx (unsigned char *d, unsigned char *s, int m);
        -:   44:static inline int my_strncmp(unsigned char *a, unsigned char *b, int n);
        -:   45:static inline int my_strncasecmp(unsigned char *a, unsigned char *b, int n);
        -:   46:static void * DFC_REALLOC(void *p, uint16_t n, dfcDataType type, dfcMemoryType type2 );
        -:   47:static void DFC_FREE(void *p, int n, dfcMemoryType type);
        -:   48:static void * DFC_MALLOC(int n, dfcMemoryType type );
        -:   49:static void Build_pattern(DFC_PATTERN *p, uint8_t *flag, uint8_t *temp, uint32_t i, int j, int k);
        -:   50:static inline DFC_PATTERN *DFC_InitHashLookup(DFC_STRUCTURE *ctx, uint8_t *pat, uint16_t patlen, int nocase);
        -:   51:static inline int DFC_InitHashAdd(DFC_STRUCTURE *ctx, DFC_PATTERN *p);
        -:   52:/*************************************************************************************/
        -:   53:
        -:   54:
        -:   55:/*
        -:   56:*  Create a new DFC state machine
        -:   57:*/
    #####:   58:DFC_STRUCTURE * DFC_New (void)
        -:   59:{
        -:   60:    DFC_STRUCTURE * p;
        -:   61:
    #####:   62:    init_xlatcase ();
        -:   63:
    #####:   64:    dfc_total_memory = 0;
    #####:   65:    dfc_pattern_memory = 0;
        -:   66:
    #####:   67:    p = (DFC_STRUCTURE *)DFC_MALLOC(sizeof (DFC_STRUCTURE), DFC_MEMORY_TYPE__DFC);
    #####:   68:    MEMASSERT_DFC (p, "DFC_New");
        -:   69:
    #####:   70:    if (p)
        -:   71:    {
    #####:   72:        memset (p, 0, sizeof (DFC_STRUCTURE));
    #####:   73:        p->init_hash = malloc(sizeof(DFC_PATTERN *) * INIT_HASH_SIZE);
    #####:   74:        if(p->init_hash == NULL){
    #####:   75:            exit(1);
        -:   76:        }
    #####:   77:        memset(p->init_hash, 0, sizeof(DFC_PATTERN *) * INIT_HASH_SIZE);
    #####:   78:    }
        -:   79:
    #####:   80:    return p;
        -:   81:}
        -:   82:
    #####:   83:static void DFC_FreePattern(DFC_PATTERN *p){
    #####:   84:    if(p->patrn != NULL){
    #####:   85:        free(p->patrn);
    #####:   86:    }
        -:   87:
    #####:   88:    if(p->casepatrn != NULL){
    #####:   89:        free(p->casepatrn);
    #####:   90:    }
        -:   91:
    #####:   92:    return;
        -:   93:}
        -:   94:
    #####:   95:static void DFC_FreePatternList(DFC_STRUCTURE *dfc){
        -:   96:    DFC_PATTERN *plist;
        -:   97:    DFC_PATTERN *p_next;
        -:   98:
    #####:   99:	for(plist = dfc->dfcPatterns; plist != NULL;){
    #####:  100:        DFC_FreePattern(plist);
    #####:  101:        p_next = plist->next;
    #####:  102:        free(plist);
    #####:  103:        plist = p_next;
        -:  104:    }
        -:  105:
    #####:  106:    return;
        -:  107:}
        -:  108:
    #####:  109:void DFC_FreeStructure(DFC_STRUCTURE *dfc){
        -:  110:    BUC_CNT_TYPE j, l;
        -:  111:    int i,k;
    #####:  112:    if(dfc == NULL)
    #####:  113:        return;
        -:  114:
    #####:  115:    if(dfc->dfcPatterns != NULL){
    #####:  116:        DFC_FreePatternList(dfc);
    #####:  117:    }
        -:  118:
    #####:  119:    if(dfc->dfcMatchList != NULL){
    #####:  120:        free(dfc->dfcMatchList);
    #####:  121:    }
        -:  122:
    #####:  123:    for(i = 0; i < CT2_TABLE_SIZE; i++){
    #####:  124:        for(j = 0; j < dfc->CompactTable2[i].cnt; j++){
    #####:  125:            free(dfc->CompactTable2[i].array[j].pid);
        -:  126:
    #####:  127:            if(dfc->CompactTable2[i].array[j].DirectFilter != NULL){
    #####:  128:                free(dfc->CompactTable2[i].array[j].DirectFilter);
    #####:  129:            }
        -:  130:
    #####:  131:            if(dfc->CompactTable2[i].array[j].CompactTable != NULL){
    #####:  132:                for(k = 0; k < RECURSIVE_CT_SIZE; k++){
    #####:  133:                    for(l = 0; l < dfc->CompactTable2[i].array[j].CompactTable[k].cnt; l++){
    #####:  134:                        free(dfc->CompactTable2[i].array[j].CompactTable[k].array[l].pid);
    #####:  135:                    }
    #####:  136:                    free(dfc->CompactTable2[i].array[j].CompactTable[k].array);
    #####:  137:                }
    #####:  138:                free(dfc->CompactTable2[i].array[j].CompactTable);
    #####:  139:            }
        -:  140:        
    #####:  141:        }
    #####:  142:    }
        -:  143:
    #####:  144:    for(i = 0; i < CT4_TABLE_SIZE; i++){
    #####:  145:        for(j = 0; j < dfc->CompactTable4[i].cnt; j++){
    #####:  146:            free(dfc->CompactTable4[i].array[j].pid);
        -:  147:
    #####:  148:            if(dfc->CompactTable4[i].array[j].DirectFilter != NULL){
    #####:  149:                free(dfc->CompactTable4[i].array[j].DirectFilter);
    #####:  150:            }
        -:  151:
    #####:  152:            if(dfc->CompactTable4[i].array[j].CompactTable != NULL){
    #####:  153:                for(k = 0; k < RECURSIVE_CT_SIZE; k++){
    #####:  154:                    for(l = 0; l < dfc->CompactTable4[i].array[j].CompactTable[k].cnt; l++){
    #####:  155:                        free(dfc->CompactTable4[i].array[j].CompactTable[k].array[l].pid);
    #####:  156:                    }
    #####:  157:                    free(dfc->CompactTable4[i].array[j].CompactTable[k].array);
    #####:  158:                }
    #####:  159:                free(dfc->CompactTable4[i].array[j].CompactTable);
    #####:  160:            }
        -:  161:        
    #####:  162:        }
    #####:  163:    }
        -:  164:
    #####:  165:    for(i = 0; i < CT8_TABLE_SIZE; i++){
    #####:  166:        for(j = 0; j < dfc->CompactTable8[i].cnt; j++){
    #####:  167:            free(dfc->CompactTable8[i].array[j].pid);
        -:  168:
    #####:  169:            if(dfc->CompactTable8[i].array[j].DirectFilter != NULL){
    #####:  170:                free(dfc->CompactTable8[i].array[j].DirectFilter);
    #####:  171:            }
        -:  172:
    #####:  173:            if(dfc->CompactTable8[i].array[j].CompactTable != NULL){
    #####:  174:                for(k = 0; k < RECURSIVE_CT_SIZE; k++){
    #####:  175:                    for(l = 0; l < dfc->CompactTable8[i].array[j].CompactTable[k].cnt; l++){
    #####:  176:                        free(dfc->CompactTable8[i].array[j].CompactTable[k].array[l].pid);
    #####:  177:                    }
    #####:  178:                    free(dfc->CompactTable8[i].array[j].CompactTable[k].array);
    #####:  179:                }
    #####:  180:                free(dfc->CompactTable8[i].array[j].CompactTable);
    #####:  181:            }
        -:  182:        
    #####:  183:        }
    #####:  184:    }
        -:  185:
    #####:  186:    free(dfc);
    #####:  187:}
        -:  188:
        -:  189:
        -:  190:/*
        -:  191:*  Add a pattern to the list of patterns
        -:  192:*
        -:  193:*
        -:  194:* \param dfc    Pointer to the DFC structure
        -:  195:* \param pat    Pointer to the pattern
        -:  196:* \param n      Pattern length
        -:  197:* \param nocase Flag for case-sensitivity (0 means case-insensitive, 1 means the opposite)
        -:  198:* \param sid    External id
        -:  199:*
        -:  200:* \retval   0 On success to add new pattern.
        -:  201:* \retval   1 On success to add sid.
        -:  202:*/
    #####:  203:int DFC_AddPattern (DFC_STRUCTURE * dfc, unsigned char *pat, int n, int nocase, PID_TYPE sid)
        -:  204:{
    #####:  205:    DFC_PATTERN * plist = DFC_InitHashLookup(dfc, pat, n, nocase);
        -:  206:
    #####:  207:    if(plist == NULL){
    #####:  208:        plist = (DFC_PATTERN *) DFC_MALLOC(sizeof (DFC_PATTERN), DFC_MEMORY_TYPE__PATTERN);
    #####:  209:        MEMASSERT_DFC (plist, "DFC_AddPattern");
    #####:  210:        memset(plist, 0, sizeof(DFC_PATTERN));
        -:  211:
    #####:  212:        plist->patrn = (unsigned char *)DFC_MALLOC(n, DFC_MEMORY_TYPE__PATTERN);
    #####:  213:        MEMASSERT_DFC (plist->patrn, "DFC_AddPattern");
        -:  214:
    #####:  215:        ConvertCaseEx(plist->patrn, pat, n);
        -:  216:
    #####:  217:        plist->casepatrn = (unsigned char *)DFC_MALLOC(n,DFC_MEMORY_TYPE__PATTERN);
    #####:  218:        MEMASSERT_DFC (plist->casepatrn, "DFC_AddPattern");
        -:  219:
    #####:  220:        memcpy (plist->casepatrn, pat, n);
        -:  221:
    #####:  222:        plist->n      = n;
    #####:  223:        plist->nocase = nocase;
    #####:  224:        plist->iid    = dfc->numPatterns; // internal id
    #####:  225:        plist->next   = NULL;
        -:  226:
    #####:  227:        DFC_InitHashAdd(dfc, plist);
        -:  228:
        -:  229:        /* sid update */
    #####:  230:        plist->sids_size = 1;
    #####:  231:        plist->sids = (PID_TYPE *) DFC_MALLOC(sizeof(PID_TYPE), DFC_MEMORY_TYPE__PATTERN);
    #####:  232:        MEMASSERT_DFC (plist->sids, "DFC_AddPattern");
    #####:  233:        plist->sids[0] = sid;
        -:  234:
        -:  235:        /* Add this pattern to the list */
    #####:  236:        dfc->numPatterns++;
        -:  237:
    #####:  238:        return 0;
        -:  239:    }else{
    #####:  240:        int found = 0;
    #####:  241:        uint32_t x = 0;
        -:  242:
    #####:  243:        for (x = 0; x < plist->sids_size; x++) {
    #####:  244:            if (plist->sids[x] == sid) {
    #####:  245:                found = 1;
    #####:  246:                break;
        -:  247:            }
    #####:  248:        }
        -:  249:
    #####:  250:        if (!found) {
    #####:  251:            PID_TYPE *sids = (PID_TYPE *)DFC_REALLOC(plist->sids, plist->sids_size + 1,
        -:  252:                                                     DFC_PID_TYPE, DFC_MEMORY_TYPE__PATTERN);
    #####:  253:            plist->sids = sids;
    #####:  254:            plist->sids[plist->sids_size] = sid;
    #####:  255:            plist->sids_size++;
    #####:  256:        }
        -:  257:
    #####:  258:        return 1;
        -:  259:    }
    #####:  260:}
        -:  261:
        -:  262:
    #####:  263:void DFC_PrintInfo(DFC_STRUCTURE* dfc){
        -:  264:	DFC_PATTERN *plist;
        -:  265:    BUC_CNT_TYPE j;
        -:  266:	int i;
    #####:  267:	int nl1 = 0, nl2 = 0, nl3 = 0, nl4 = 0, nl8 = 0;
        -:  268:
    #####:  269:	int nocase_pat_cnt = 0;
    #####:  270:	for(plist = dfc->dfcPatterns; plist != NULL; plist = plist->next){
    #####:  271:        if (plist->n == 1) {
    #####:  272:			nl1 ++;
    #####:  273:        }else if (plist->n == 2) {
    #####:  274:			nl2 ++;
    #####:  275:        }else if (plist->n == 3) {
    #####:  276:			nl3 ++;
    #####:  277:        }else if (plist->n >= 4 && plist->n < 8) {
    #####:  278:			nl4 ++;
    #####:  279:        }else if (plist->n >= 8) {
    #####:  280:			nl8 ++;
    #####:  281:		}
        -:  282:
    #####:  283:		if(plist->nocase){
    #####:  284:			nocase_pat_cnt++;
    #####:  285:		}
    #####:  286:	}
        -:  287:
    #####:  288:	int nb1 = 0, nb2 = 0,nb3 = 0,nb4 = 0,nb5 = 0, nb8 = 0;
    #####:  289:	int nb9 = 0;
    #####:  290:	for(i = 0; i < DF_SIZE_REAL ;i++)
    #####:  291:		nb1 += __builtin_popcount(dfc->DirectFilter1[i]);
    #####:  292:	for(i = 0; i < DF_SIZE_REAL ;i++)
    #####:  293:		nb2 += __builtin_popcount(dfc->ADD_DF_4_plus[i]);
    #####:  294:	for(i = 0; i < DF_SIZE_REAL ;i++)
    #####:  295:		nb3 += __builtin_popcount(dfc->ADD_DF_8_1[i]);
    #####:  296:	for(i = 0; i < 256 ;i++)
    #####:  297:		nb4 += __builtin_popcount(dfc->cDF0[i]);
    #####:  298:	for(i = 0; i < DF_SIZE_REAL ;i++)
    #####:  299:		nb8 += __builtin_popcount(dfc->ADD_DF_4_1[i]);
    #####:  300:	for(i = 0; i < DF_SIZE_REAL ;i++)
    #####:  301:		nb9 += __builtin_popcount(dfc->cDF2[i]);
        -:  302:
        -:  303:	/* CT 1*/
    #####:  304:	int ct1_array_cnt = 0;
    #####:  305:	int ct1_pid_cnt = 0;
    #####:  306:	float ct1_pid_std_dev = 0;
    #####:  307:	for(i=0; i < CT1_TABLE_SIZE; i++){
    #####:  308:		ct1_pid_cnt += dfc->CompactTable1[i].cnt;
    #####:  309:		if(dfc->CompactTable1[i].cnt != 0)
    #####:  310:			ct1_array_cnt++;
    #####:  311:	}
    #####:  312:	for(i=0; i < CT1_TABLE_SIZE; i++){
    #####:  313:		ct1_pid_std_dev += (dfc->CompactTable1[i].cnt - ((float)ct1_pid_cnt/CT1_TABLE_SIZE)) *
    #####:  314:								(dfc->CompactTable1[i].cnt - ((float)ct1_pid_cnt/CT1_TABLE_SIZE));
    #####:  315:	}
    #####:  316:	ct1_pid_std_dev /= ct1_pid_cnt;
    #####:  317:	ct1_pid_std_dev = my_sqrtf(ct1_pid_std_dev,ct1_pid_std_dev);
        -:  318:
        -:  319:	/* CT 2*/
    #####:  320:	BUC_CNT_TYPE ct2_array_min = 9999999;
    #####:  321:	BUC_CNT_TYPE ct2_array_max = 0;
    #####:  322:	PID_CNT_TYPE ct2_pid_min = 9999999;
    #####:  323:	PID_CNT_TYPE ct2_pid_max = 0;
    #####:  324:	int ct2_array_cnt = 0;
    #####:  325:	int ct2_array_tot_cnt = 0;
    #####:  326:	int ct2_pid_cnt = 0;
    #####:  327:	int ct2_pid_tot_cnt = 0;
    #####:  328:	float ct2_array_std_dev = 0;
    #####:  329:	float ct2_pid_std_dev = 0;
    #####:  330:	for(i=0; i < CT2_TABLE_SIZE; i++){
    #####:  331:		ct2_array_tot_cnt += dfc->CompactTable2[i].cnt;	
    #####:  332:		if(ct2_array_min > dfc->CompactTable2[i].cnt) ct2_array_min = dfc->CompactTable2[i].cnt;
    #####:  333:		if(ct2_array_max < dfc->CompactTable2[i].cnt) ct2_array_max = dfc->CompactTable2[i].cnt;
    #####:  334:		if(dfc->CompactTable2[i].cnt != 0)
    #####:  335:			ct2_array_cnt++;
    #####:  336:		for(j = 0; j < dfc->CompactTable2[i].cnt; j++){
    #####:  337:			ct2_pid_tot_cnt += dfc->CompactTable2[i].array[j].cnt;
    #####:  338:			if(ct2_pid_min > dfc->CompactTable2[i].array[j].cnt) 
    #####:  339:                ct2_pid_min = dfc->CompactTable2[i].array[j].cnt;
    #####:  340:			if(ct2_pid_max < dfc->CompactTable2[i].array[j].cnt) 
    #####:  341:                ct2_pid_max = dfc->CompactTable2[i].array[j].cnt;
    #####:  342:			if(dfc->CompactTable2[i].array[j].cnt != 0)
    #####:  343:				ct2_pid_cnt++;
    #####:  344:		}
    #####:  345:	}
    #####:  346:	for(i=0; i < CT2_TABLE_SIZE; i++){
    #####:  347:		if(dfc->CompactTable2[i].cnt != 0){
    #####:  348:			ct2_array_std_dev += (dfc->CompactTable2[i].cnt - ((float)ct2_array_tot_cnt/ct2_array_cnt))*
    #####:  349:								 (dfc->CompactTable2[i].cnt - ((float)ct2_array_tot_cnt/ct2_array_cnt));	
    #####:  350:		}
    #####:  351:		for(j = 0; j < dfc->CompactTable2[i].cnt; j++){
    #####:  352:			if(dfc->CompactTable2[i].array[j].cnt != 0){
    #####:  353:				ct2_pid_std_dev += (dfc->CompactTable2[i].array[j].cnt 
    #####:  354:                                    - ((float)ct2_pid_tot_cnt/ct2_pid_cnt)) *
    #####:  355:								   (dfc->CompactTable2[i].array[j].cnt 
    #####:  356:                                    - ((float)ct2_pid_tot_cnt/ct2_pid_cnt));
    #####:  357:			}
    #####:  358:		}
    #####:  359:	}
        -:  360:
    #####:  361:	ct2_array_std_dev /=ct2_array_cnt;
    #####:  362:	ct2_pid_std_dev /=ct2_pid_cnt;
        -:  363:
    #####:  364:	ct2_array_std_dev = my_sqrtf(ct2_array_std_dev, ct2_array_std_dev);
    #####:  365:	ct2_pid_std_dev = my_sqrtf(ct2_pid_std_dev, ct2_pid_std_dev);
        -:  366:
        -:  367:	/* CT4 */
    #####:  368:	BUC_CNT_TYPE ct4_array_min = 9999999;
    #####:  369:	BUC_CNT_TYPE ct4_array_max = 0;
    #####:  370:	PID_CNT_TYPE ct4_pid_min = 9999999;
    #####:  371:	PID_CNT_TYPE ct4_pid_max = 0;
    #####:  372:	int ct4_array_cnt = 0;
    #####:  373:	int ct4_mt2f_array_cnt = 0; // # of buckets that has more than 2 frags (mt2f : more than 2 fragments)
    #####:  374:	int ct4_mt2f_frag_cnt = 0; 
    #####:  375:	int ct4_array_tot_cnt = 0;
    #####:  376:	int ct4_pid_cnt = 0;
    #####:  377:	int ct4_pid_tot_cnt = 0;
    #####:  378:	float ct4_array_std_dev = 0;
    #####:  379:	float ct4_pid_std_dev = 0;
    #####:  380:	for(i=0; i < CT4_TABLE_SIZE; i++){
    #####:  381:		ct4_array_tot_cnt += dfc->CompactTable4[i].cnt;	
    #####:  382:		if(ct4_array_min > dfc->CompactTable4[i].cnt) ct4_array_min = dfc->CompactTable4[i].cnt;
    #####:  383:		if(ct4_array_max < dfc->CompactTable4[i].cnt) ct4_array_max = dfc->CompactTable4[i].cnt;
    #####:  384:		if(dfc->CompactTable4[i].cnt != 0)
    #####:  385:			ct4_array_cnt++;
    #####:  386:		if(dfc->CompactTable4[i].cnt >= 2){
    #####:  387:			ct4_mt2f_array_cnt++;
    #####:  388:            ct4_mt2f_frag_cnt += (dfc->CompactTable4[i].cnt - 1);
    #####:  389:        }
    #####:  390:		for(j = 0; j < dfc->CompactTable4[i].cnt; j++){
    #####:  391:			ct4_pid_tot_cnt += dfc->CompactTable4[i].array[j].cnt;
    #####:  392:			if(ct4_pid_min > dfc->CompactTable4[i].array[j].cnt) 
    #####:  393:                ct4_pid_min = dfc->CompactTable4[i].array[j].cnt;
    #####:  394:			if(ct4_pid_max < dfc->CompactTable4[i].array[j].cnt) 
    #####:  395:                ct4_pid_max = dfc->CompactTable4[i].array[j].cnt;
    #####:  396:			if(dfc->CompactTable4[i].array[j].cnt != 0)
    #####:  397:				ct4_pid_cnt++;
    #####:  398:		}
    #####:  399:	}
    #####:  400:	for(i=0; i < CT4_TABLE_SIZE; i++){
    #####:  401:		if(dfc->CompactTable4[i].cnt != 0){
    #####:  402:			ct4_array_std_dev += (dfc->CompactTable4[i].cnt - ((float)ct4_array_tot_cnt/ct4_array_cnt))*
    #####:  403:								 (dfc->CompactTable4[i].cnt - ((float)ct4_array_tot_cnt/ct4_array_cnt));	
    #####:  404:		}
    #####:  405:		for(j = 0; j < dfc->CompactTable4[i].cnt; j++){
    #####:  406:			if(dfc->CompactTable4[i].array[j].cnt != 0){
    #####:  407:				ct4_pid_std_dev += (dfc->CompactTable4[i].array[j].cnt 
    #####:  408:                                    - ((float)ct4_pid_tot_cnt/ct4_pid_cnt)) *
    #####:  409:								   (dfc->CompactTable4[i].array[j].cnt 
    #####:  410:                                    - ((float)ct4_pid_tot_cnt/ct4_pid_cnt));
    #####:  411:			}
    #####:  412:		}
    #####:  413:	}
        -:  414:
    #####:  415:	ct4_array_std_dev /=ct4_array_cnt;
    #####:  416:	ct4_pid_std_dev /=ct4_pid_cnt;
        -:  417:
    #####:  418:	ct4_array_std_dev = my_sqrtf(ct4_array_std_dev, ct4_array_std_dev);
    #####:  419:	ct4_pid_std_dev = my_sqrtf(ct4_pid_std_dev, ct4_pid_std_dev);
        -:  420:
        -:  421:	/* CT8 */
    #####:  422:	BUC_CNT_TYPE ct8_array_min = 9999999;
    #####:  423:	BUC_CNT_TYPE ct8_array_max = 0;
    #####:  424:	PID_CNT_TYPE ct8_pid_min = 9999999;
    #####:  425:	PID_CNT_TYPE ct8_pid_max = 0;
    #####:  426:	int ct8_array_cnt = 0;
    #####:  427:    int ct8_mt2f_array_cnt = 0; // # of buckets that has more than 2 frags (mt2f : more than 2 fragments)
    #####:  428:    int ct8_mt2f_frag_cnt = 0;
    #####:  429:	int ct8_array_tot_cnt = 0;
    #####:  430:	int ct8_pid_cnt = 0;
    #####:  431:	int ct8_pid_tot_cnt = 0;
    #####:  432:	float ct8_array_std_dev = 0;
    #####:  433:	float ct8_pid_std_dev = 0;
    #####:  434:	for(i=0; i < CT8_TABLE_SIZE; i++){
    #####:  435:		ct8_array_tot_cnt += dfc->CompactTable8[i].cnt;	
    #####:  436:		if(ct8_array_min > dfc->CompactTable8[i].cnt) ct8_array_min = dfc->CompactTable8[i].cnt;
    #####:  437:		if(ct8_array_max < dfc->CompactTable8[i].cnt) ct8_array_max = dfc->CompactTable8[i].cnt;
    #####:  438:		if(dfc->CompactTable8[i].cnt != 0)
    #####:  439:			ct8_array_cnt++;
    #####:  440:		if(dfc->CompactTable8[i].cnt >= 2){
    #####:  441:			ct8_mt2f_array_cnt++;
    #####:  442:            ct8_mt2f_frag_cnt += (dfc->CompactTable8[i].cnt - 1);
    #####:  443:        }
    #####:  444:		for(j = 0; j < dfc->CompactTable8[i].cnt; j++){
    #####:  445:			ct8_pid_tot_cnt += dfc->CompactTable8[i].array[j].cnt;
    #####:  446:			if(ct8_pid_min > dfc->CompactTable8[i].array[j].cnt) 
    #####:  447:                ct8_pid_min = dfc->CompactTable8[i].array[j].cnt;
    #####:  448:			if(ct8_pid_max < dfc->CompactTable8[i].array[j].cnt) 
    #####:  449:                ct8_pid_max = dfc->CompactTable8[i].array[j].cnt;
    #####:  450:			if(dfc->CompactTable8[i].array[j].cnt != 0)
    #####:  451:				ct8_pid_cnt++;
    #####:  452:		}
    #####:  453:	}
    #####:  454:	for(i=0; i < CT8_TABLE_SIZE; i++){
    #####:  455:		if(dfc->CompactTable8[i].cnt != 0){
    #####:  456:			ct8_array_std_dev += (dfc->CompactTable8[i].cnt - ((float)ct8_array_tot_cnt/ct8_array_cnt))*
    #####:  457:								 (dfc->CompactTable8[i].cnt - ((float)ct8_array_tot_cnt/ct8_array_cnt));	
    #####:  458:		}
    #####:  459:		for(j = 0; j < dfc->CompactTable8[i].cnt; j++){
    #####:  460:			if(dfc->CompactTable8[i].array[j].cnt != 0){
    #####:  461:				ct8_pid_std_dev += (dfc->CompactTable8[i].array[j].cnt 
    #####:  462:                                    - ((float)ct8_pid_tot_cnt/ct8_pid_cnt)) *
    #####:  463:								   (dfc->CompactTable8[i].array[j].cnt 
    #####:  464:                                    - ((float)ct8_pid_tot_cnt/ct8_pid_cnt));
    #####:  465:			}
    #####:  466:		}
    #####:  467:	}
        -:  468:
    #####:  469:	ct8_array_std_dev /=ct8_array_cnt;
    #####:  470:	ct8_pid_std_dev /=ct8_pid_cnt;
        -:  471:
    #####:  472:	ct8_array_std_dev = my_sqrtf(ct8_array_std_dev, ct8_array_std_dev);
    #####:  473:	ct8_pid_std_dev = my_sqrtf(ct8_pid_std_dev, ct8_pid_std_dev);
        -:  474:
    #####:  475:	printf("\n");
    #####:  476:	printf("+- [ Direct Filter + Compact Table(DFC) Summary ] -------------------------------------\n");
    #####:  477:	printf("| Patterns: %5d (Case-Insensitive patterns: %d)\n", dfc->numPatterns, nocase_pat_cnt);
    #####:  478:	printf("|   - 1B      : %5d\n", nl1);
    #####:  479:	printf("|   - 2B      : %5d\n", nl2);
    #####:  480:	printf("|   - 3B      : %5d\n", nl3);
    #####:  481:	printf("|   - 4B ~ 7B : %5d\n", nl4);
    #####:  482:	printf("|   - 8B ~    : %5d\n", nl8);
    #####:  483:	printf("|\n");
    #####:  484:	printf("| < Direct Filter Density > \n");
    #####:  485:	printf("|   1. All patterns(DF1)            : %.6f (%4d)\n", (double)nb1/DF_SIZE, nb1);
    #####:  486:	printf("|     1) 1B patterns(DF4)           : %.6f (%4d)\n", (double)nb4/DF_SIZE, nb4);
    #####:  487:	printf("|     2) 2B patterns(DF5)           : %.6f (%4d)\n", (double)nb5/DF_SIZE, nb5);
    #####:  488:	printf("|     4) 4B ~ patterns(DF2)         : %.6f (%4d)\n", (double)nb2/DF_SIZE, nb2);
    #####:  489:	printf("|       (1) 4B ~ 7B patterns(DF8)   : %.6f (%4d)\n", (double)nb8/DF_SIZE, nb8);
    #####:  490:	printf("|          I. 4B ~ 7B patterns(DF9) : %.6f (%4d)\n", (double)nb9/DF_SIZE, nb9);
    #####:  491:	printf("|       (2) 8B ~ patterns(DF3)      : %.6f (%4d)\n", (double)nb3/DF_SIZE, nb3);
    #####:  492:	printf("|\n");
    #####:  493:	printf("| < Compact Table 1 Density >\n");
    #####:  494:	printf("|   - Compact Table 1(CT1) Size   : %u\n", CT1_TABLE_SIZE);
    #####:  495:	printf("|   - Number of non-empty buckets : %d\n", ct1_array_cnt);
    #####:  496:	printf("|   - Total num of PIDs in CT1    : %d\n", ct1_pid_cnt);
    #####:  497:	printf("|   - Number of PIDs per bucket   : %.3f\n", (double)ct1_pid_cnt/ct1_array_cnt);
    #####:  498:	printf("|   - Std Deviation for # of PID  : %.3f\n", ct1_pid_std_dev);
    #####:  499:	printf("|\n");
    #####:  500:	printf("| < Compact Table 2 Density >\n");
    #####:  501:	printf("|   - Compact Table 2(CT2) Size   : %u\n", CT2_TABLE_SIZE);
    #####:  502:	printf("|   - Total # of buckets in CT2   : %d\n", ct2_array_cnt);
    #####:  503:	printf("|   - Avr # of fragments/bucket   : %.3f (none zero)\n", (double)ct2_array_tot_cnt/ct2_array_cnt);
    #####:  504:	printf("|   - Std Dev for # of fragments  : %.3f\n", ct2_array_std_dev);
    #####:  505:	printf("|   - Min/Max for # of fragments  : %u / %u\n", ct2_array_min, ct2_array_max);
    #####:  506:	printf("|\n");
    #####:  507:	printf("|     - Total # of PIDs in CT2    : %d\n", ct2_pid_tot_cnt);
    #####:  508:	printf("|     - Avr # of PIDs per frag    : %.3f (none zero)\n", (double)ct2_pid_tot_cnt/ct2_pid_cnt);
    #####:  509:	printf("|     - Std Dev for # of PID      : %.3f\n", ct2_pid_std_dev);
    #####:  510:	printf("|     - Min/Max for # of PID      : %u / %u\n", ct2_pid_min, ct2_pid_max);
    #####:  511:	printf("|\n");
    #####:  512:	printf("| < Compact Table 4 Density >\n");
    #####:  513:	printf("|   - Compact Table 4(CT4) Size   : %u\n", CT4_TABLE_SIZE);
    #####:  514:	printf("|   - Total # of buckets in CT4   : %d\n", ct4_array_cnt);
    #####:  515:	printf("|   - Avr # of fragments/bucket   : %.3f (collision rate: %.5f (%d/%d))\n", 
    #####:  516:                                                (double)ct4_array_tot_cnt/ct4_array_cnt,
    #####:  517:                                                (double)ct4_mt2f_frag_cnt/ct4_array_cnt,
    #####:  518:                                                ct4_mt2f_frag_cnt, ct4_array_cnt);
    #####:  519:	printf("|   - Std Dev for # of fragments  : %.3f\n", ct4_array_std_dev);
    #####:  520:	printf("|   - Min/Max for # of fragments  : %u / %u\n", ct4_array_min, ct4_array_max);
    #####:  521:	printf("|\n");
    #####:  522:	printf("|     - Total # of PIDs in CT4    : %d\n", ct4_pid_tot_cnt);
    #####:  523:	printf("|     - Avr # of PIDs per frag    : %.3f (none zero)\n", (double)ct4_pid_tot_cnt/ct4_pid_cnt);
    #####:  524:	printf("|     - Std Dev for # of PID      : %.3f\n", ct4_pid_std_dev);
    #####:  525:	printf("|     - Min/Max for # of PID      : %u / %u\n", ct4_pid_min, ct4_pid_max);
    #####:  526:	printf("|\n");
    #####:  527:	printf("| < Compact Table 8 Density >\n");
    #####:  528:	printf("|   - Compact Table 8(CT8) Size   : %u\n", CT8_TABLE_SIZE);
    #####:  529:	printf("|   - Total # of buckets in CT8   : %d\n", ct8_array_cnt);
    #####:  530:	printf("|   - Avr # of fragments/bucket   : %.3f (collision rate: %.5f (%d/%d))\n", 
    #####:  531:                                                (double)ct8_array_tot_cnt/ct8_array_cnt,
    #####:  532:                                                (double)ct8_mt2f_frag_cnt/ct8_array_cnt,
    #####:  533:                                                ct8_mt2f_frag_cnt, ct8_array_cnt);
    #####:  534:	printf("|   - Std Dev for # of fragments  : %.3f\n", ct8_array_std_dev);
    #####:  535:	printf("|   - Min/Max for # of fragments  : %u / %u\n", ct8_array_min, ct8_array_max);
    #####:  536:	printf("|\n");
    #####:  537:	printf("|     - Total # of PIDs in CT8    : %d\n", ct8_pid_tot_cnt);
    #####:  538:	printf("|     - Avr # of PIDs per frag    : %.3f (none zero)\n", (double)ct8_pid_tot_cnt/ct8_pid_cnt);
    #####:  539:	printf("|     - Std Dev for # of PID      : %.3f\n", ct8_pid_std_dev);
    #####:  540:	printf("|     - Min/Max for # of PID      : %u / %u\n", ct8_pid_min, ct8_pid_max);
    #####:  541:	printf("|\n");
        -:  542:
    #####:  543:	if (dfc_total_memory < 1024 * 1024)
    #####:  544:	printf("| Total Memory (KB) : %.2f\n", (float)dfc_total_memory/1024);
        -:  545:	else
    #####:  546:	printf("| Total Memory (MB) : %.2f\n", (float)dfc_total_memory/(1024*1024));
        -:  547:
    #####:  548:	if (dfc_pattern_memory < 1024 * 1024)
    #####:  549:	printf("|   - Pattern Memory (KB) : %.2f\n", (float)dfc_pattern_memory/1024);
        -:  550:	else
    #####:  551:	printf("|   - Pattern Memory (MB) : %.2f\n", (float)dfc_pattern_memory/(1024*1024));
        -:  552:
    #####:  553:	if (dfc_memory_dfs < 1024 * 1024)
    #####:  554:	printf("|   - DF Memory (KB) : %.2f\n", (float)dfc_memory_dfs/1024);
        -:  555:	else
    #####:  556:	printf("|   - DF Memory (MB) : %.2f\n", (float)dfc_memory_dfs/(1024*1024));
        -:  557:	
    #####:  558:	if (dfc_memory_ct1 < 1024 * 1024)
    #####:  559:	printf("|   - CT1 Memory (KB) : %.2f\n", (float)dfc_memory_ct1/1024);
        -:  560:	else
    #####:  561:	printf("|   - CT1 Memory (MB) : %.2f\n", (float)dfc_memory_ct1/(1024*1024));
        -:  562:	
    #####:  563:	if (dfc_memory_ct2 < 1024 * 1024)
    #####:  564:	printf("|   - CT2 Memory (KB) : %.2f\n", (float)dfc_memory_ct2/1024);
        -:  565:	else
    #####:  566:	printf("|   - CT2 Memory (MB) : %.2f\n", (float)dfc_memory_ct2/(1024*1024));
        -:  567:	
    #####:  568:	if (dfc_memory_ct4 < 1024 * 1024)
    #####:  569:	printf("|   - CT4 Memory (KB) : %.2f\n", (float)dfc_memory_ct4/1024);
        -:  570:	else
    #####:  571:	printf("|   - CT4 Memory (MB) : %.2f\n", (float)dfc_memory_ct4/(1024*1024));
        -:  572:	
    #####:  573:	if (dfc_memory_ct8 < 1024 * 1024)
    #####:  574:	printf("|   - CT8 Memory (KB) : %.2f\n", (float)dfc_memory_ct8/1024);
        -:  575:	else
    #####:  576:	printf("|   - CT8 Memory (MB) : %.2f\n", (float)dfc_memory_ct8/(1024*1024));
    #####:  577:	printf("+--------------------------------------------------------------------------------------\n\n");
        -:  578:
    #####:  579:	return;
        -:  580:
        -:  581:}
        -:  582:
    #####:  583:static void Add_PID_to_2B_CT(CT_Type_2_2B * CompactTable, uint8_t *temp, PID_TYPE pid, dfcMemoryType type){
        -:  584:    BUC_CNT_TYPE j;
        -:  585:	PID_CNT_TYPE k;
    #####:  586:	uint32_t crc = _mm_crc32_u16(0, *(uint16_t*)temp);
        -:  587:
    #####:  588:	crc &= CT2_TABLE_SIZE_MASK;
        -:  589:
    #####:  590:	if( CompactTable[crc].cnt != 0){
    #####:  591:		for(j = 0; j < CompactTable[crc].cnt; j++){
    #####:  592:			if( CompactTable[crc].array[j].pat == *(uint16_t*)temp )
    #####:  593:				break;
    #####:  594:		}
        -:  595:
    #####:  596:		if( j == CompactTable[crc].cnt){ // If not found,
    #####:  597:			CompactTable[crc].cnt++;
    #####:  598:			CompactTable[crc].array =
    #####:  599:				(CT_Type_2_2B_Array *)DFC_REALLOC((void*)CompactTable[crc].array,
    #####:  600:							CompactTable[crc].cnt, DFC_CT_Type_2_2B_Array, type);
    #####:  601:			CompactTable[crc].array[CompactTable[crc].cnt-1].pat = *(uint16_t*)temp;
        -:  602:
    #####:  603:			CompactTable[crc].array[CompactTable[crc].cnt-1].cnt = 1;
    #####:  604:			CompactTable[crc].array[CompactTable[crc].cnt-1].pid =
    #####:  605:									(PID_TYPE *)DFC_MALLOC(sizeof(PID_TYPE), type);
    #####:  606:			CompactTable[crc].array[CompactTable[crc].cnt-1].pid[0] = pid;
    #####:  607:		}else{ // If found,
    #####:  608:			for(k = 0; k < CompactTable[crc].array[j].cnt; k++){
    #####:  609:				if(CompactTable[crc].array[j].pid[k] == pid)
    #####:  610:					break;
    #####:  611:			}
    #####:  612:			if( k == CompactTable[crc].array[j].cnt ){
    #####:  613:				CompactTable[crc].array[j].cnt++;
    #####:  614:				CompactTable[crc].array[j].pid =
    #####:  615:					 (PID_TYPE *)DFC_REALLOC((void*)CompactTable[crc].array[j].pid,
    #####:  616:						CompactTable[crc].array[j].cnt, DFC_PID_TYPE, type);
    #####:  617:				CompactTable[crc].array[j].pid[CompactTable[crc].array[j].cnt-1] =
    #####:  618:					 pid;
    #####:  619:			}
        -:  620:		}
    #####:  621:	}else{ // If there is no elements in the CT4,
    #####:  622:		CompactTable[crc].cnt = 1;
    #####:  623:		CompactTable[crc].array = (CT_Type_2_2B_Array *)DFC_MALLOC(sizeof(CT_Type_2_2B_Array), type);
    #####:  624:		memset(CompactTable[crc].array, 0, sizeof(CT_Type_2_2B_Array));
        -:  625:
    #####:  626:		CompactTable[crc].array[0].pat = *(uint16_t*)temp;
    #####:  627:		CompactTable[crc].array[0].cnt = 1;
    #####:  628:		CompactTable[crc].array[0].pid = (PID_TYPE *)DFC_MALLOC(sizeof(PID_TYPE), type);
    #####:  629:		CompactTable[crc].array[0].pid[0] = pid;
        -:  630:	}	
        -:  631:
    #####:  632:}
        -:  633:
    #####:  634:int DFC_Compile(DFC_STRUCTURE* dfc)
        -:  635:{
    #####:  636:	uint32_t i=0;
        -:  637:    uint32_t alpha_cnt;
        -:  638:
        -:  639:    int j, k, l;
        -:  640:    BUC_CNT_TYPE m, n;
        -:  641:	DFC_PATTERN *plist;
        -:  642:
        -:  643:    uint8_t temp[8], flag[8];
        -:  644:    uint16_t fragment_16;
        -:  645:    uint32_t fragment_32;
        -:  646:    uint64_t fragment_64;
        -:  647:    uint32_t byteIndex, bitMask;
        -:  648:
    #####:  649:	dfc_memory_ct1 = sizeof(CT_Type_1)    * CT1_TABLE_SIZE;
    #####:  650:	dfc_memory_ct2 = 0;
    #####:  651:	dfc_memory_ct3 = 0;
    #####:  652:	dfc_memory_ct4 = 0;
    #####:  653:	dfc_memory_ct8 = 0;
    #####:  654:	dfc_total_memory = sizeof(DFC_STRUCTURE) + dfc_pattern_memory;
        -:  655:
        -:  656:/* ####################################################################################### */
        -:  657:/* ###############                  MatchList initialization              ################ */
        -:  658:/* ####################################################################################### */
    #####:  659:    int begin_node_flag = 1;
    #####:  660:    for (i = 0; i < INIT_HASH_SIZE; i++) {
    #####:  661:        DFC_PATTERN *node = dfc->init_hash[i], *prev_node;
    #####:  662:        int first_node_flag = 1;
    #####:  663:        while(node != NULL) {
    #####:  664:            if(begin_node_flag){
    #####:  665:                begin_node_flag = 0;
    #####:  666:                dfc->dfcPatterns = node;
    #####:  667:            }else{
    #####:  668:                if(first_node_flag){
    #####:  669:                    first_node_flag = 0;
    #####:  670:                    prev_node->next = node;
    #####:  671:                }
        -:  672:            }
    #####:  673:            prev_node = node;
    #####:  674:            node = node->next;
        -:  675:        }
    #####:  676:    }
        -:  677:
    #####:  678:    free(dfc->init_hash);
    #####:  679:    dfc->init_hash = NULL;
        -:  680:
    #####:  681:	dfc->dfcMatchList = (DFC_PATTERN **)DFC_MALLOC(sizeof(DFC_PATTERN*) * dfc->numPatterns, 
        -:  682:									    						DFC_MEMORY_TYPE__PATTERN);
    #####:  683:    MEMASSERT_DFC(dfc->dfcMatchList, "DFC_Compile");
        -:  684:
    #####:  685:	for(plist = dfc->dfcPatterns; plist != NULL; plist = plist->next){
    #####:  686:        if(dfc->dfcMatchList[plist->iid] != NULL){
    #####:  687:            fprintf(stderr, "Internal ID ERROR : %u\n", plist->iid);
    #####:  688:        }
    #####:  689:		dfc->dfcMatchList[plist->iid] = plist;
    #####:  690:	}
        -:  691:
        -:  692:
        -:  693:/* ####################################################################################### */
        -:  694:
        -:  695:/* ####################################################################################### */
        -:  696:/* ###############              0. Direct Filters initialization          ################ */
        -:  697:/* ####################################################################################### */
        -:  698:
        -:  699:    /* Initializing Bloom Filter */
    #####:  700:    for (i = 0; i < DF_SIZE_REAL; i++) {
    #####:  701:        dfc->DirectFilter1[i] = 0;
    #####:  702:        dfc->ADD_DF_4_plus[i] = 0;
    #####:  703:        dfc->ADD_DF_8_1[i] = 0;
    #####:  704:        dfc->ADD_DF_4_1[i] = 0;
    #####:  705:        dfc->cDF2[i] = 0;
    #####:  706:        dfc->ADD_DF_8_2[i] = 0;
    #####:  707:        dfc->cDF1[i] = 0;
    #####:  708:    }
        -:  709:
    #####:  710:    for(i = 0; i < 256; i++){
    #####:  711:        dfc->cDF0[i] = 0;
    #####:  712:    }
        -:  713:
        -:  714:/* ####################################################################################### */
        -:  715:
        -:  716:/* ####################################################################################### */
        -:  717:/* ###############            1. Decide extracting position               ################ */
        -:  718:/* ####################################################################################### */
    #####:  719:	pattern_interval = 32;
    #####:  720:    min_pattern_interval = 0;
        -:  721:#if 0
        -:  722:    int min_bit_count = 65536;
        -:  723:    int max_bucket_cnt = 0;
        -:  724:
        -:  725:    uint8_t tmpADD_DF_8_1_2[DF_SIZE_REAL];
        -:  726:    uint8_t tmpADD_DF_8_1_3[DF_SIZE_REAL];
        -:  727:    uint8_t tmpADD_DF_8_1_4[DF_SIZE_REAL];
        -:  728:    uint8_t tmpDirectFilter1[DF_SIZE_REAL];
        -:  729:	CT_Type_2_8B tmpCompactTable8[CT8_TABLE_SIZE];
        -:  730:
        -:  731:    for(i = 0; i <= pattern_interval; i++)
        -:  732:    {
        -:  733:        int l;
        -:  734:        int pcount = 0;
        -:  735:		memset(tmpDirectFilter1, 0, sizeof(uint8_t) * DF_SIZE_REAL);
        -:  736:		memset(tmpADD_DF_8_1_2, 0, sizeof(uint8_t) * DF_SIZE_REAL);
        -:  737:		memset(tmpADD_DF_8_1_3, 0, sizeof(uint8_t) * DF_SIZE_REAL);
        -:  738:		memset(tmpADD_DF_8_1_4, 0, sizeof(uint8_t) * DF_SIZE_REAL);
        -:  739:		memset(tmpCompactTable8, 0, sizeof(CT_Type_2_8B) * CT8_TABLE_SIZE);
        -:  740:
        -:  741:        for(plist = dfc->dfcPatterns; plist != NULL; plist = plist->next){
        -:  742:            if (plist->n > 1) {
        -:  743:                alpha_cnt = 0;
        -:  744:
        -:  745:                do {
        -:  746:                    for (j=1, k=0; j>=0; --j, k++) {
        -:  747:                        flag[k] =  (alpha_cnt >> j) & 1;
        -:  748:                    }
        -:  749:
        -:  750:                    if (plist->n == 2) {
        -:  751:                        for (j=plist->n - 2, k=0; j< plist->n; j++, k++){
        -:  752:                            Build_pattern(plist, flag, temp, i,j,k);
        -:  753:                        }
        -:  754:                    }else if (plist->n == 3) {
        -:  755:                        for (j=0 , k=0; j < 2; j++, k++){
        -:  756:                            Build_pattern(plist, flag, temp, i,j,k);
        -:  757:                        }
        -:  758:                    }else if (plist->n < 8) {
        -:  759:                        for (j=plist->n - 4, k=0; j< plist->n-2; j++, k++){
        -:  760:                            Build_pattern(plist, flag, temp, i,j,k);
        -:  761:                        }
        -:  762:                    } else { // len >= 8
        -:  763:						uint8_t temp2[8];
        -:  764:                        for (j = i*(plist->n-8)/pattern_interval, k=0; 
        -:  765:							 j < i*(plist->n-8)/pattern_interval+8; j++,k++){
        -:  766:                            Build_pattern(plist, flag, temp, i,j,k);
        -:  767:							temp2[k] = plist->patrn[j];
        -:  768:                        }
        -:  769:						uint64_t crc = _mm_crc32_u64(0, *(uint64_t*)temp2);
        -:  770:						crc &= CT8_TABLE_SIZE_MASK;
        -:  771:
        -:  772:#if 1
        -:  773:						if( tmpCompactTable8[crc].cnt != 0){ 
        -:  774:							for(j = 0; j < tmpCompactTable8[crc].cnt; j++){
        -:  775:								if( tmpCompactTable8[crc].array[j].pat == *(uint64_t*)temp2 )
        -:  776:									break;	
        -:  777:							}
        -:  778:
        -:  779:							if( j == tmpCompactTable8[crc].cnt){ // If not found,
        -:  780:								tmpCompactTable8[crc].cnt++;
        -:  781:								tmpCompactTable8[crc].array = 
        -:  782:									(CT_Type_2_8B_Array *)DFC_REALLOC((void*)tmpCompactTable8[crc].array,
        -:  783:									tmpCompactTable8[crc].cnt, DFC_CT_Type_2_8B_Array, DFC_MEMORY_TYPE__NONE);
        -:  784:								tmpCompactTable8[crc].
        -:  785:										array[tmpCompactTable8[crc].cnt-1].pat=*(uint64_t*)temp2;
        -:  786:
        -:  787:								tmpCompactTable8[crc].array[tmpCompactTable8[crc].cnt-1].cnt = 1;
        -:  788:							}
        -:  789:						}else{ // If there is no elements in the CT8,
        -:  790:							tmpCompactTable8[crc].cnt = 1;
        -:  791:							tmpCompactTable8[crc].array =
        -:  792:									 (CT_Type_2_8B_Array *)DFC_MALLOC(sizeof(CT_Type_2_8B_Array),
        -:  793:																				 DFC_MEMORY_TYPE__NONE);
        -:  794:							memset(tmpCompactTable8[crc].array, 0, sizeof(CT_Type_2_8B_Array));
        -:  795:
        -:  796:							tmpCompactTable8[crc].array[0].pat = *(uint64_t*)temp2;
        -:  797:							tmpCompactTable8[crc].array[0].cnt = 1;
        -:  798:						} 
        -:  799:#endif
        -:  800:                    }
        -:  801:
        -:  802:                    byteIndex = (uint32_t)BINDEX((*(uint16_t*)temp) & DF_MASK);
        -:  803:                    bitMask = BMASK((*(uint16_t*)temp) & DF_MASK);
        -:  804:
        -:  805:                    tmpDirectFilter1[byteIndex] |= bitMask;
        -:  806:                    if(!i)
        -:  807:                    {
        -:  808:                        if (plist->n == 2) {
        -:  809:                            dfc->DirectFilter5[byteIndex] |= bitMask;
        -:  810:                        } else if (plist->n == 3) {
        -:  811:                            dfc->DirectFilter6[byteIndex] |= bitMask;
        -:  812:                        }
        -:  813:                    }
        -:  814:                    alpha_cnt++;
        -:  815:                } while (alpha_cnt < 4);
        -:  816:            }
        -:  817:            if (plist->n >= 8) {
        -:  818:                alpha_cnt = 0;
        -:  819:                pcount++;
        -:  820:                do {
        -:  821:                    for (j=7, k=0; j>=0; --j, k++) {
        -:  822:                        flag[k] =  (alpha_cnt >> j) & 1;
        -:  823:                    }
        -:  824:
        -:  825:                    for (j=i*(plist->n - 8)/pattern_interval, k=0; j< i*(plist->n-8)/pattern_interval+8; j++, k++){
        -:  826:                        Build_pattern(plist, flag, temp, i,j,k);
        -:  827:                    }
        -:  828:
        -:  829:                    byteIndex = BINDEX((*(((uint16_t*)temp)+1)) & DF_MASK);
        -:  830:                    bitMask = BMASK((*(((uint16_t*)temp)+1)) & DF_MASK);
        -:  831:                    tmpADD_DF_8_1_2[byteIndex] |= bitMask;
        -:  832:
        -:  833:                    byteIndex = BINDEX((*(((uint16_t*)temp)+2)) & DF_MASK);
        -:  834:                    bitMask = BMASK((*(((uint16_t*)temp)+2)) & DF_MASK);
        -:  835:                    tmpADD_DF_8_1_3[byteIndex] |= bitMask;
        -:  836:
        -:  837:                    byteIndex = BINDEX((*(((uint16_t*)temp)+3)) & DF_MASK);
        -:  838:                    bitMask = BMASK((*(((uint16_t*)temp)+3)) & DF_MASK);
        -:  839:                    tmpADD_DF_8_1_4[byteIndex] |= bitMask;
        -:  840:
        -:  841:                    alpha_cnt++;
        -:  842:                } while (alpha_cnt < 256);
        -:  843:            }
        -:  844:        }
        -:  845:        int bit_count = 0;
        -:  846:        int bit_count_8_2 = 0;
        -:  847:        int bit_count_8_3 = 0;
        -:  848:        int bit_count_8_4 = 0;
        -:  849:        int bit_count_ct8 = 0;
        -:  850:        for(l = 0; l < DF_SIZE_REAL; l++)
        -:  851:        {
        -:  852:            bit_count += __builtin_popcount(tmpDirectFilter1[l]);
        -:  853:            bit_count_8_2 += __builtin_popcount(tmpADD_DF_8_1_2[l]);
        -:  854:            bit_count_8_3 += __builtin_popcount(tmpADD_DF_8_1_3[l]);
        -:  855:            bit_count_8_4 += __builtin_popcount(tmpADD_DF_8_1_4[l]);
        -:  856:        }
        -:  857:        for(l = 0; l < CT8_TABLE_SIZE; l++)
        -:  858:        {
        -:  859:            //bit_count_ct8 += __builtin_popcount(tmpCompactTable8[l]);
        -:  860:            bit_count_ct8 += tmpCompactTable8[l].cnt;
        -:  861:			DFC_FREE(tmpCompactTable8[l].array, sizeof(CT_Type_2_8B_Array) * tmpCompactTable8[l].cnt);
        -:  862:		}
        -:  863:        //if(bit_count < min_bit_count && (double)bit_count_8/pcount < 1.45)
        -:  864:        //if(bit_count < min_bit_count)
        -:  865:        //if(bit_count_ct8 < max_bucket_cnt)
        -:  866:        if(bit_count_8_3 + bit_count_8_4 < min_bit_count)
        -:  867:        {
        -:  868:            min_bit_count = bit_count_8_3 + bit_count_8_4;
        -:  869:            min_pattern_interval = i;
        -:  870:        }
        -:  871:		//printf("position: %d, DF1: %d, DF3_2 (8B): %d, DF3_3 (8B): %d, DF3_4 (8B): %d # of buckets in CT8: %d\n",
        -:  872:		//			 i, bit_count, bit_count_8_2, bit_count_8_3, bit_count_8_4 , bit_count_ct8);
        -:  873:    }
        -:  874:#endif
    #####:  875:	min_pattern_interval = 32;
        -:  876:	//printf("Extracting Position : %d/%d\n", min_pattern_interval, pattern_interval);
        -:  877:
        -:  878:
        -:  879:
        -:  880:/* ####################################################################################### */
        -:  881:
        -:  882:/* ####################################################################################### */
        -:  883:/* ###############               Direct Filters setup                     ################ */
        -:  884:/* ####################################################################################### */
    #####:  885:    memset(dfc->CompactTable1, 0, sizeof(CT_Type_1)*CT1_TABLE_SIZE);
        -:  886:
    #####:  887:	for(plist = dfc->dfcPatterns; plist != NULL; plist = plist->next){
        -:  888:		/* 0. Initialization for DF8 (for 1B patterns)*/
    #####:  889:        if (plist->n == 1) {
    #####:  890:            temp[0] = plist->casepatrn[0];
    #####:  891:            for(j = 0; j < 256; j++){
    #####:  892:                temp[1] = j;
        -:  893:
    #####:  894:                fragment_16 = (temp[1] << 8) | temp[0];
    #####:  895:                byteIndex = (uint32_t)BINDEX(fragment_16 & DF_MASK);
    #####:  896:                bitMask = BMASK(fragment_16 & DF_MASK);
        -:  897:
    #####:  898:                dfc->DirectFilter1[byteIndex] |= bitMask;
    #####:  899:            }
        -:  900:
    #####:  901:            dfc->cDF0[temp[0]] = 1;
    #####:  902:			if(dfc->CompactTable1[temp[0]].cnt == 0){
    #####:  903:				dfc->CompactTable1[temp[0]].cnt++;
    #####:  904:				dfc->CompactTable1[temp[0]].pid[0] = plist->iid;
    #####:  905:			}else{
    #####:  906:				for(k = 0; k < dfc->CompactTable1[temp[0]].cnt; k++){
    #####:  907:					if(dfc->CompactTable1[temp[0]].pid[k] == plist->iid)
    #####:  908:						break;
    #####:  909:				}
    #####:  910:				if(k == dfc->CompactTable1[temp[0]].cnt){
    #####:  911:					dfc->CompactTable1[temp[0]].pid[dfc->CompactTable1[temp[0]].cnt++] = plist->iid;
    #####:  912:					if(dfc->CompactTable1[temp[0]].cnt >= CT_TYPE1_PID_CNT_MAX)
    #####:  913:						printf("Too many PIDs in CT1. You should expand the size.\n");
    #####:  914:				}
        -:  915:			}
        -:  916:
    #####:  917:			if(plist->nocase){
    #####:  918:				if(plist->casepatrn[0] >= 97/*a*/ && plist->casepatrn[0] <= 122/*z*/){
        -:  919:					/* when the pattern is lower case */
    #####:  920:					temp[0] = toupper(plist->casepatrn[0]);
    #####:  921:				}else{	
        -:  922:					/* when the pattern is upper case */
    #####:  923:					temp[0] = tolower(plist->casepatrn[0]);
        -:  924:				}
        -:  925:
    #####:  926:				for(j = 0; j < 256; j++){
    #####:  927:					temp[1] = j;
        -:  928:
    #####:  929:                    fragment_16 = (temp[1] << 8) | temp[0];
    #####:  930:					byteIndex = (uint32_t)BINDEX(fragment_16 & DF_MASK);
    #####:  931:					bitMask = BMASK(fragment_16 & DF_MASK);
        -:  932:
    #####:  933:					dfc->DirectFilter1[byteIndex] |= bitMask;
    #####:  934:				}
        -:  935:
    #####:  936:				dfc->cDF0[temp[0]] = 1;
    #####:  937:				if(dfc->CompactTable1[temp[0]].cnt == 0){
    #####:  938:					dfc->CompactTable1[temp[0]].cnt++;
    #####:  939:					dfc->CompactTable1[temp[0]].pid[0] = plist->iid;
    #####:  940:				}else{
    #####:  941:					for(k = 0; k < dfc->CompactTable1[temp[0]].cnt; k++){
    #####:  942:						if(dfc->CompactTable1[temp[0]].pid[k] == plist->iid)
    #####:  943:							break;
    #####:  944:					}
    #####:  945:					if(k == dfc->CompactTable1[temp[0]].cnt){
    #####:  946:						dfc->CompactTable1[temp[0]].pid[dfc->CompactTable1[temp[0]].cnt++] = plist->iid;
    #####:  947:						if(dfc->CompactTable1[temp[0]].cnt >= CT_TYPE1_PID_CNT_MAX)
    #####:  948:							printf("Too many PIDs in CT1. You should expand the size.\n");
    #####:  949:					}
        -:  950:				}
    #####:  951:			}
    #####:  952:        }
        -:  953:
        -:  954:	    /* 1. Initialization for DF1 */
    #####:  955:        if (plist->n > 1) {
    #####:  956:            alpha_cnt = 0;
        -:  957:
    #####:  958:            do {
    #####:  959:                for (j=1, k=0; j>=0; --j, k++) {
    #####:  960:                    flag[k] =  (alpha_cnt >> j) & 1;
    #####:  961:                }
        -:  962:
    #####:  963:				if (plist->n == 2) {
    #####:  964:                    for (j=plist->n - 2, k=0; j< plist->n; j++, k++){
    #####:  965:                        Build_pattern(plist, flag, temp, i,j,k);
    #####:  966:                    }
    #####:  967:				}else if (plist->n == 3) {
        -:  968:                    //for (j=0 , k=0; j < 2; j++, k++){
    #####:  969:                    for (j=plist->n - 2, k=0; j< plist->n; j++, k++){
    #####:  970:                        Build_pattern(plist, flag, temp, i,j,k);
    #####:  971:                    }
    #####:  972:				}else if (plist->n < 8) {
    #####:  973:                    for (j=plist->n - 4, k=0; j< plist->n-2; j++, k++){
    #####:  974:                        Build_pattern(plist, flag, temp, i,j,k);
    #####:  975:                    }
    #####:  976:                } else { // len >= 8
    #####:  977:                    for (j = min_pattern_interval*(plist->n-8)/pattern_interval, k = 0; 
    #####:  978:						 j < min_pattern_interval*(plist->n - 8)/pattern_interval + 2; j++, k++){
    #####:  979:                        Build_pattern(plist, flag, temp, i,j,k);
    #####:  980:                    }
        -:  981:                }
        -:  982:
    #####:  983:                fragment_16 = (temp[1] << 8) | temp[0];
    #####:  984:                byteIndex = (uint32_t)BINDEX(fragment_16 & DF_MASK);
    #####:  985:                bitMask = BMASK(fragment_16 & DF_MASK);
        -:  986:
    #####:  987:                dfc->DirectFilter1[byteIndex] |= bitMask;
        -:  988:
    #####:  989:				if(plist->n == 2 || plist->n == 3)
    #####:  990:					dfc->cDF1[byteIndex] |= bitMask;
        -:  991:
    #####:  992:                alpha_cnt++;
    #####:  993:            } while (alpha_cnt < 4);
    #####:  994:        }
        -:  995:
        -:  996:		/* Initializing 4B DF, 8B DF */
    #####:  997:        if (plist->n >= 4) {
    #####:  998:            alpha_cnt = 0;
        -:  999:
    #####: 1000:            do {
    #####: 1001:                for (j=3, k=0; j>=0; --j, k++) {
    #####: 1002:                    flag[k] =  (alpha_cnt >> j) & 1;
    #####: 1003:                }
        -: 1004:
    #####: 1005:                if (plist->n < 8) {
    #####: 1006:                    for (j=plist->n - 4, k=0; j< plist->n; j++, k++) {
    #####: 1007:                        Build_pattern(plist, flag, temp, i,j,k);
    #####: 1008:                    }
    #####: 1009:                } else {
    #####: 1010:                    for (j = min_pattern_interval*(plist->n-8)/pattern_interval, k=0;
    #####: 1011:						 j < min_pattern_interval*(plist->n-8)/pattern_interval + 4; j++, k++) {
    #####: 1012:                        Build_pattern(plist, flag, temp, i,j,k);
    #####: 1013:                    }
        -: 1014:                }
        -: 1015:
    #####: 1016:                byteIndex = BINDEX((*(((uint16_t*)temp)+1)) & DF_MASK);
    #####: 1017:                bitMask = BMASK((*(((uint16_t*)temp)+1)) & DF_MASK);
        -: 1018:
    #####: 1019:                dfc->ADD_DF_4_plus[byteIndex] |= bitMask;
    #####: 1020:                if (plist->n >= 4 && plist->n < 8) {
    #####: 1021:                    dfc->ADD_DF_4_1[byteIndex] |= bitMask;
        -: 1022:
    #####: 1023:                    fragment_16 = (temp[1] << 8) | temp[0];
    #####: 1024:                    byteIndex = BINDEX(fragment_16 & DF_MASK);
    #####: 1025:                    bitMask = BMASK(fragment_16 & DF_MASK);
        -: 1026:
    #####: 1027:                    dfc->cDF2[byteIndex] |= bitMask;
    #####: 1028:				}
    #####: 1029:                alpha_cnt++;
    #####: 1030:            } while (alpha_cnt < 16);
    #####: 1031:        }
        -: 1032:
    #####: 1033:        if (plist->n >= 8) {
    #####: 1034:            alpha_cnt = 0;
        -: 1035:
    #####: 1036:            do {
    #####: 1037:                for (j=7, k=0; j>=0; --j, k++) {
    #####: 1038:                    flag[k] =  (alpha_cnt >> j) & 1;
    #####: 1039:                }
        -: 1040:
    #####: 1041:                for (j = min_pattern_interval*(plist->n - 8)/pattern_interval, k=0; 
    #####: 1042:					 j < min_pattern_interval*(plist->n - 8)/pattern_interval + 8; j++, k++){
    #####: 1043:                    Build_pattern(plist, flag, temp, i,j,k);
    #####: 1044:                }
        -: 1045:
    #####: 1046:                byteIndex = BINDEX((*(((uint16_t*)temp)+3)) & DF_MASK);
    #####: 1047:                bitMask = BMASK((*(((uint16_t*)temp)+3)) & DF_MASK);
        -: 1048:
    #####: 1049:                dfc->ADD_DF_8_1[byteIndex] |= bitMask;
        -: 1050:
    #####: 1051:                byteIndex = BINDEX((*(((uint16_t*)temp)+2)) & DF_MASK);
    #####: 1052:                bitMask = BMASK((*(((uint16_t*)temp)+2)) & DF_MASK);
        -: 1053:
    #####: 1054:                dfc->ADD_DF_8_2[byteIndex] |= bitMask;
        -: 1055:
    #####: 1056:                alpha_cnt++;
    #####: 1057:            } while (alpha_cnt < 256);
    #####: 1058:        }
        -: 1059:
    #####: 1060:    }
        -: 1061:
        -: 1062:    //printf("DF Initialization is done.\n");
        -: 1063:/* ####################################################################################### */
        -: 1064:
        -: 1065:/* ####################################################################################### */
        -: 1066:/* ###############                Compact Tables initialization           ################ */
        -: 1067:/* ####################################################################################### */
        -: 1068:
    #####: 1069:	dfc_memory_ct2 += sizeof(CT_Type_2)*CT2_TABLE_SIZE;
    #####: 1070:    memset(dfc->CompactTable2, 0, sizeof(CT_Type_2)*CT2_TABLE_SIZE);
        -: 1071:
    #####: 1072:	dfc_memory_ct4 += sizeof(CT_Type_2)*CT4_TABLE_SIZE;
    #####: 1073:    memset(dfc->CompactTable4, 0, sizeof(CT_Type_2)*CT4_TABLE_SIZE);
        -: 1074:
    #####: 1075:	dfc_memory_ct8 += sizeof(CT_Type_2_8B)*CT8_TABLE_SIZE;
    #####: 1076:    memset(dfc->CompactTable8, 0, sizeof(CT_Type_2_8B)*CT8_TABLE_SIZE);
        -: 1077:
        -: 1078:
        -: 1079:/* ####################################################################################### */
        -: 1080:
        -: 1081:/* ####################################################################################### */
        -: 1082:/* ###############                   Compact Tables setup                 ################ */
        -: 1083:/* ####################################################################################### */
        -: 1084:
    #####: 1085:	for(plist = dfc->dfcPatterns; plist != NULL; plist = plist->next){
    #####: 1086:        if (plist->n == 2 || plist->n == 3) {
    #####: 1087:			alpha_cnt = 0;
        -: 1088:
    #####: 1089:            do {
    #####: 1090:                for (j=1, k=0; j>=0; --j, k++) {
    #####: 1091:                    flag[k] =  (alpha_cnt >> j) & 1;
    #####: 1092:                }
        -: 1093:
    #####: 1094:                for (j=plist->n - 2, k=0; j< plist->n; j++, k++){
    #####: 1095:                    Build_pattern(plist, flag, temp, i,j,k);
    #####: 1096:                }
        -: 1097:
        -: 1098:				 // 2.
    #####: 1099:                fragment_16 = (temp[1] << 8) | temp[0];
    #####: 1100:                uint32_t crc = _mm_crc32_u16(0, fragment_16);
        -: 1101:
        -: 1102:                // 3.
    #####: 1103:                crc &= CT2_TABLE_SIZE_MASK;
        -: 1104:
        -: 1105:                // 4.
    #####: 1106:                if( dfc->CompactTable2[crc].cnt != 0){
    #####: 1107:                    for(n = 0; n < dfc->CompactTable2[crc].cnt; n++){
    #####: 1108:                        if( dfc->CompactTable2[crc].array[n].pat == fragment_16 )
    #####: 1109:                            break;
    #####: 1110:                    }
        -: 1111:
    #####: 1112:                    if( n == dfc->CompactTable2[crc].cnt){ // If not found,
    #####: 1113:                        dfc->CompactTable2[crc].cnt++;
    #####: 1114:                        dfc->CompactTable2[crc].array =
    #####: 1115:                            (CT_Type_2_Array *)DFC_REALLOC((void*)dfc->CompactTable2[crc].array,
    #####: 1116:                                        dfc->CompactTable2[crc].cnt, DFC_CT_Type_2_Array, DFC_MEMORY_TYPE__CT2);
    #####: 1117:                        dfc->CompactTable2[crc].array[dfc->CompactTable2[crc].cnt-1].pat = fragment_16;
        -: 1118:
    #####: 1119:                        dfc->CompactTable2[crc].array[dfc->CompactTable2[crc].cnt-1].cnt = 1;
    #####: 1120:                        dfc->CompactTable2[crc].array[dfc->CompactTable2[crc].cnt-1].pid =
    #####: 1121:                                                (PID_TYPE *)DFC_MALLOC(sizeof(PID_TYPE), DFC_MEMORY_TYPE__CT2);
    #####: 1122:                        dfc->CompactTable2[crc].array[dfc->CompactTable2[crc].cnt-1].pid[0] = plist->iid;
    #####: 1123:						dfc->CompactTable2[crc].array[dfc->CompactTable2[crc].cnt-1].DirectFilter = NULL;
    #####: 1124:						dfc->CompactTable2[crc].array[dfc->CompactTable2[crc].cnt-1].CompactTable = NULL;
    #####: 1125:                    }else{ // If found,
    #####: 1126:                        for(m = 0; m < dfc->CompactTable2[crc].array[n].cnt; m++){
    #####: 1127:                            if(dfc->CompactTable2[crc].array[n].pid[m] == plist->iid)
    #####: 1128:                                break;
    #####: 1129:                        }
    #####: 1130:                        if( m == dfc->CompactTable2[crc].array[n].cnt ){
    #####: 1131:                            dfc->CompactTable2[crc].array[n].cnt++;
    #####: 1132:                            dfc->CompactTable2[crc].array[n].pid =
    #####: 1133:                                 (PID_TYPE *)DFC_REALLOC((void*)dfc->CompactTable2[crc].array[n].pid,
    #####: 1134:                                    dfc->CompactTable2[crc].array[n].cnt, DFC_PID_TYPE, DFC_MEMORY_TYPE__CT2);
    #####: 1135:                            dfc->CompactTable2[crc].array[n].pid[dfc->CompactTable2[crc].array[n].cnt-1] =
    #####: 1136:                                 plist->iid;
    #####: 1137:                        }
        -: 1138:                    }
    #####: 1139:                }else{ // If there is no elements in the CT4,
    #####: 1140:                    dfc->CompactTable2[crc].cnt = 1;
    #####: 1141:                    dfc->CompactTable2[crc].array = (CT_Type_2_Array *)DFC_MALLOC(sizeof(CT_Type_2_Array),
        -: 1142:                                                                                             DFC_MEMORY_TYPE__CT2);
    #####: 1143:                    memset(dfc->CompactTable2[crc].array, 0, sizeof(CT_Type_2_Array));
        -: 1144:
    #####: 1145:                    dfc->CompactTable2[crc].array[0].pat = fragment_16;
    #####: 1146:                    dfc->CompactTable2[crc].array[0].cnt = 1;
    #####: 1147:                    dfc->CompactTable2[crc].array[0].pid = (PID_TYPE *)DFC_MALLOC(sizeof(PID_TYPE),
        -: 1148:                                                                             DFC_MEMORY_TYPE__CT2);
    #####: 1149:                    dfc->CompactTable2[crc].array[0].pid[0] = plist->iid;
    #####: 1150:					dfc->CompactTable2[crc].array[0].DirectFilter = NULL;
    #####: 1151:					dfc->CompactTable2[crc].array[0].CompactTable = NULL;
        -: 1152:                }
        -: 1153:
    #####: 1154:                alpha_cnt++;
    #####: 1155:            } while (alpha_cnt < 4);
    #####: 1156:        }
        -: 1157:
        -: 1158:		/* CT4 initialization */
    #####: 1159:        if (plist->n >= 4 && plist->n < 8) {
    #####: 1160:            alpha_cnt = 0;
    #####: 1161:            do {
        -: 1162:				// 1. 
        -: 1163:
    #####: 1164:				for (j=3, k=0; j>=0; --j, k++) {
    #####: 1165:					flag[k] =  (alpha_cnt >> j) & 1;
    #####: 1166:				}
        -: 1167:
    #####: 1168:				for (j=plist->n - 4, k=0; j< plist->n; j++, k++){
    #####: 1169:					Build_pattern(plist, flag, temp, i,j,k);
    #####: 1170:				}
        -: 1171:
        -: 1172:				// 2.		
    #####: 1173:                fragment_32 = (temp[3] << 24) | (temp[2] << 16) | (temp[1] << 8) | temp[0];
    #####: 1174:				uint32_t crc = _mm_crc32_u32(0, fragment_32);
        -: 1175:
        -: 1176:				// 3.
    #####: 1177:				crc &= CT4_TABLE_SIZE_MASK;			
        -: 1178:
        -: 1179:				// 4.
    #####: 1180:				if( dfc->CompactTable4[crc].cnt != 0){ 
    #####: 1181:					for(n = 0; n < dfc->CompactTable4[crc].cnt; n++){
    #####: 1182:						if( dfc->CompactTable4[crc].array[n].pat == fragment_32 )
    #####: 1183:							break;	
    #####: 1184:					}
        -: 1185:
    #####: 1186:					if( n == dfc->CompactTable4[crc].cnt){ // If not found,
    #####: 1187:						dfc->CompactTable4[crc].cnt++;
    #####: 1188:						dfc->CompactTable4[crc].array = 
    #####: 1189:							(CT_Type_2_Array *)DFC_REALLOC((void*)dfc->CompactTable4[crc].array,
    #####: 1190:										dfc->CompactTable4[crc].cnt, DFC_CT_Type_2_Array, DFC_MEMORY_TYPE__CT4);
    #####: 1191:						dfc->CompactTable4[crc].array[dfc->CompactTable4[crc].cnt-1].pat = fragment_32;
        -: 1192:
    #####: 1193:						dfc->CompactTable4[crc].array[dfc->CompactTable4[crc].cnt-1].cnt = 1;
    #####: 1194:						dfc->CompactTable4[crc].array[dfc->CompactTable4[crc].cnt-1].pid = 
    #####: 1195:												(PID_TYPE *)DFC_MALLOC(sizeof(PID_TYPE), DFC_MEMORY_TYPE__CT4);
    #####: 1196:						dfc->CompactTable4[crc].array[dfc->CompactTable4[crc].cnt-1].pid[0] = plist->iid;
    #####: 1197:						dfc->CompactTable4[crc].array[dfc->CompactTable4[crc].cnt-1].DirectFilter = NULL;
    #####: 1198:						dfc->CompactTable4[crc].array[dfc->CompactTable4[crc].cnt-1].CompactTable = NULL;
    #####: 1199:					}else{ // If found,
    #####: 1200:						for(m = 0; m < dfc->CompactTable4[crc].array[n].cnt; m++){
    #####: 1201:							if(dfc->CompactTable4[crc].array[n].pid[m] == plist->iid)
    #####: 1202:								break;
    #####: 1203:						}
    #####: 1204:						if( m == dfc->CompactTable4[crc].array[n].cnt ){
    #####: 1205:							dfc->CompactTable4[crc].array[n].cnt++;
    #####: 1206:							dfc->CompactTable4[crc].array[n].pid =
    #####: 1207:								 (PID_TYPE *)DFC_REALLOC((void*)dfc->CompactTable4[crc].array[n].pid,
    #####: 1208:									dfc->CompactTable4[crc].array[n].cnt, DFC_PID_TYPE, DFC_MEMORY_TYPE__CT4);
    #####: 1209:							dfc->CompactTable4[crc].array[n].pid[dfc->CompactTable4[crc].array[n].cnt-1] =
    #####: 1210:								 plist->iid;
    #####: 1211:						}
        -: 1212:					}
    #####: 1213:				}else{ // If there is no elements in the CT4,
    #####: 1214:					dfc->CompactTable4[crc].cnt = 1;
    #####: 1215:					dfc->CompactTable4[crc].array = (CT_Type_2_Array *)DFC_MALLOC(sizeof(CT_Type_2_Array),
        -: 1216:																							 DFC_MEMORY_TYPE__CT4);
    #####: 1217:					memset(dfc->CompactTable4[crc].array, 0, sizeof(CT_Type_2_Array));
        -: 1218:
    #####: 1219:					dfc->CompactTable4[crc].array[0].pat = fragment_32;
    #####: 1220:					dfc->CompactTable4[crc].array[0].cnt = 1;
    #####: 1221:					dfc->CompactTable4[crc].array[0].pid = (PID_TYPE *)DFC_MALLOC(sizeof(PID_TYPE),
        -: 1222:																			 DFC_MEMORY_TYPE__CT4);
    #####: 1223:					dfc->CompactTable4[crc].array[0].pid[0] = plist->iid;
    #####: 1224:					dfc->CompactTable4[crc].array[0].DirectFilter = NULL;
    #####: 1225:					dfc->CompactTable4[crc].array[0].CompactTable = NULL;
        -: 1226:				} 
    #####: 1227:                alpha_cnt++;
    #####: 1228:            } while (alpha_cnt < 16);
    #####: 1229:        }
        -: 1230:
        -: 1231:		/* CT8 initialization */
    #####: 1232:        if (plist->n >= 8) {
    #####: 1233:            alpha_cnt = 0;
    #####: 1234:            do {
    #####: 1235:                for (j=7, k=0; j>=0; --j, k++) {
    #####: 1236:                    flag[k] =  (alpha_cnt >> j) & 1;
    #####: 1237:                }
        -: 1238:
        -: 1239:
        -: 1240:#ifdef CT8_SWITCH
    #####: 1241:				for (j = min_pattern_interval*(plist->n - 8)/pattern_interval, k=0;
    #####: 1242:					 j < min_pattern_interval*(plist->n - 8)/pattern_interval + 8; j++, k++) {
    #####: 1243:					temp[k] = plist->patrn[j];
    #####: 1244:				}
        -: 1245:#else
        -: 1246:                for (j=plist->n - 8, k=0; j< plist->n; j++, k++){
        -: 1247:                    Build_pattern(plist, flag, temp, i,j,k);
        -: 1248:                }
        -: 1249:#endif
        -: 1250:
        -: 1251:                // 1. Calulating Indice
    #####: 1252:                fragment_32 = (temp[7] << 24) | (temp[6] << 16) | (temp[5] << 8) | temp[4];
    #####: 1253:                fragment_64 = ((uint64_t)fragment_32 << 32) |
    #####: 1254:                              (temp[3] << 24) | (temp[2] << 16) | (temp[1] << 8) | temp[0];
    #####: 1255:				uint64_t crc = _mm_crc32_u64(0, fragment_64);
    #####: 1256:				crc &= CT8_TABLE_SIZE_MASK;
        -: 1257:
    #####: 1258:				if( dfc->CompactTable8[crc].cnt != 0){ 
    #####: 1259:					for(n = 0; n < dfc->CompactTable8[crc].cnt; n++){
    #####: 1260:						if( dfc->CompactTable8[crc].array[n].pat == fragment_64)
    #####: 1261:							break;	
    #####: 1262:					}
        -: 1263:
    #####: 1264:					if( n == dfc->CompactTable8[crc].cnt){ // If not found,
    #####: 1265:						dfc->CompactTable8[crc].cnt++;
    #####: 1266:						dfc->CompactTable8[crc].array = 
    #####: 1267:							(CT_Type_2_8B_Array *)DFC_REALLOC((void*)dfc->CompactTable8[crc].array,
    #####: 1268:										dfc->CompactTable8[crc].cnt, DFC_CT_Type_2_8B_Array, DFC_MEMORY_TYPE__CT8);
    #####: 1269:						dfc->CompactTable8[crc].array[dfc->CompactTable8[crc].cnt-1].pat = fragment_64;
        -: 1270:
    #####: 1271:						dfc->CompactTable8[crc].array[dfc->CompactTable8[crc].cnt-1].cnt = 1;
    #####: 1272:						dfc->CompactTable8[crc].array[dfc->CompactTable8[crc].cnt-1].pid = 
    #####: 1273:												(PID_TYPE *)DFC_MALLOC(sizeof(PID_TYPE), DFC_MEMORY_TYPE__CT8);
    #####: 1274:						dfc->CompactTable8[crc].array[dfc->CompactTable8[crc].cnt-1].pid[0] = plist->iid;
    #####: 1275:						dfc->CompactTable8[crc].array[dfc->CompactTable8[crc].cnt-1].DirectFilter = NULL;
    #####: 1276:						dfc->CompactTable8[crc].array[dfc->CompactTable8[crc].cnt-1].CompactTable = NULL;
    #####: 1277:					}else{ // If found,
    #####: 1278:						for(m = 0; m < dfc->CompactTable8[crc].array[n].cnt; m++){
    #####: 1279:							if(dfc->CompactTable8[crc].array[n].pid[m] == plist->iid)
    #####: 1280:								break;
    #####: 1281:						}
    #####: 1282:						if( m == dfc->CompactTable8[crc].array[n].cnt ){
    #####: 1283:							dfc->CompactTable8[crc].array[n].cnt++;
    #####: 1284:							dfc->CompactTable8[crc].array[n].pid =
    #####: 1285:								 (PID_TYPE *)DFC_REALLOC((void*)dfc->CompactTable8[crc].array[n].pid,
    #####: 1286:									dfc->CompactTable8[crc].array[n].cnt, DFC_PID_TYPE, DFC_MEMORY_TYPE__CT8);
    #####: 1287:							dfc->CompactTable8[crc].array[n].pid[dfc->CompactTable8[crc].array[n].cnt-1] =
    #####: 1288:																									 plist->iid;
    #####: 1289:						}
        -: 1290:					}
    #####: 1291:				}else{ // If there is no elements in the CT8,
    #####: 1292:					dfc->CompactTable8[crc].cnt = 1;
    #####: 1293:					dfc->CompactTable8[crc].array = (CT_Type_2_8B_Array *)DFC_MALLOC(sizeof(CT_Type_2_8B_Array),
        -: 1294:																							 DFC_MEMORY_TYPE__CT8);
    #####: 1295:					memset(dfc->CompactTable8[crc].array, 0, sizeof(CT_Type_2_8B_Array));
        -: 1296:
    #####: 1297:					dfc->CompactTable8[crc].array[0].pat = fragment_64;
    #####: 1298:					dfc->CompactTable8[crc].array[0].cnt = 1;
    #####: 1299:					dfc->CompactTable8[crc].array[0].pid = (PID_TYPE *)DFC_MALLOC(sizeof(PID_TYPE),
        -: 1300:																			 DFC_MEMORY_TYPE__CT8);
    #####: 1301:					dfc->CompactTable8[crc].array[0].pid[0] = plist->iid;
    #####: 1302:					dfc->CompactTable8[crc].array[0].DirectFilter = NULL;
    #####: 1303:					dfc->CompactTable8[crc].array[0].CompactTable = NULL;
        -: 1304:				} 
    #####: 1305:                alpha_cnt++;
    #####: 1306:            } while (alpha_cnt < 256);
    #####: 1307:        }
    #####: 1308:    }
        -: 1309:    //printf("CT Initialization is done.\n");
        -: 1310:/* ####################################################################################### */
        -: 1311:
        -: 1312:/* ####################################################################################### */
        -: 1313:/* ###############                   Recursive filtering                  ################ */
        -: 1314:/* ####################################################################################### */
        -: 1315:#ifdef ENABLE_RECURSIVE
        -: 1316:	// Only for CT2 firstly
        -: 1317:#if 1
    #####: 1318:	for(i=0; i < CT2_TABLE_SIZE; i++){
    #####: 1319:		for(n=0; n < dfc->CompactTable2[i].cnt; n++){
        -: 1320:			/* If the number of PID is bigger than 3, do recursive filtering */
    #####: 1321:			if(dfc->CompactTable2[i].array[n].cnt >= RECURSIVE_BOUNDARY){
        -: 1322:				/* Initialization */
    #####: 1323:				dfc->CompactTable2[i].array[n].DirectFilter=(uint8_t*)DFC_MALLOC(sizeof(uint8_t)*DF_SIZE_REAL,
        -: 1324:																						DFC_MEMORY_TYPE__CT2);
    #####: 1325:				dfc->CompactTable2[i].array[n].CompactTable=(CT_Type_2_2B*)DFC_MALLOC
        -: 1326:                                            (sizeof(CT_Type_2_2B)*RECURSIVE_CT_SIZE, DFC_MEMORY_TYPE__CT2);
        -: 1327:
    #####: 1328:				if(!dfc->CompactTable2[i].array[n].DirectFilter || !dfc->CompactTable2[i].array[n].CompactTable){
    #####: 1329:					fprintf(stderr, "Failed to allocate memory for recursive things.\n");
    #####: 1330:					return -1;
        -: 1331:				}
        -: 1332:
    #####: 1333:				PID_TYPE *tempPID = (PID_TYPE*)DFC_MALLOC(sizeof(PID_TYPE)*dfc->CompactTable2[i].array[n].cnt,
        -: 1334:																					    DFC_MEMORY_TYPE__CT2);	
    #####: 1335:				memcpy(tempPID, dfc->CompactTable2[i].array[n].pid, 
        -: 1336:														sizeof(PID_TYPE) * dfc->CompactTable2[i].array[n].cnt);
        -: 1337:				//free(dfc->CompactTable2[i].array[n].pid);
    #####: 1338:				DFC_FREE(dfc->CompactTable2[i].array[n].pid, dfc->CompactTable2[i].array[n].cnt*sizeof(PID_TYPE),
        -: 1339:															DFC_MEMORY_TYPE__CT2);
    #####: 1340:				dfc->CompactTable2[i].array[n].pid = NULL;
        -: 1341:
    #####: 1342:				int temp_cnt = 0; // cnt for 2 byte patterns.
        -: 1343:
    #####: 1344:				for(m = 0; m < dfc->CompactTable2[i].array[n].cnt; m++){
        -: 1345:					//DFC_PATTERN *mlist = dfc->dfcMatchList[]; 
    #####: 1346:					int pat_len = dfc->dfcMatchList[tempPID[m]]->n - 2;
        -: 1347:
    #####: 1348:					if(pat_len == 0){ /* When pat length is 2 */
    #####: 1349:						temp_cnt ++;
    #####: 1350:						dfc->CompactTable2[i].array[n].pid =
    #####: 1351:							 (PID_TYPE *)realloc(dfc->CompactTable2[i].array[n].pid, sizeof(PID_TYPE)*temp_cnt);
    #####: 1352:						dfc->CompactTable2[i].array[n].pid[temp_cnt-1] = tempPID[m];
    #####: 1353:					}else if (pat_len == 1){ /* When pat length is 3 */
    #####: 1354:						if(dfc->dfcMatchList[tempPID[m]]->nocase){
    #####: 1355:							temp[1] = tolower(dfc->dfcMatchList[tempPID[m]]->patrn[0]);
    #####: 1356:							for(l = 0; l < 256; l++){
    #####: 1357:								temp[0] = l;
        -: 1358:
    #####: 1359:                                fragment_16 = (temp[1] << 8) | temp[0];
    #####: 1360:								byteIndex = BINDEX(fragment_16);
    #####: 1361:								bitMask = BMASK(fragment_16);
        -: 1362:
    #####: 1363:								dfc->CompactTable2[i].array[n].DirectFilter[byteIndex] |= bitMask;
        -: 1364:
    #####: 1365:								Add_PID_to_2B_CT(dfc->CompactTable2[i].array[n].CompactTable, temp,	tempPID[m],
        -: 1366:																					DFC_MEMORY_TYPE__CT2);
    #####: 1367:							}
        -: 1368:
    #####: 1369:							temp[1] = toupper(dfc->dfcMatchList[tempPID[m]]->patrn[0]);
    #####: 1370:							for(l = 0; l < 256; l++){
    #####: 1371:								temp[0] = l;
        -: 1372:
    #####: 1373:                                fragment_16 = (temp[1] << 8) | temp[0];
    #####: 1374:								byteIndex = BINDEX(fragment_16);
    #####: 1375:								bitMask = BMASK(fragment_16);
        -: 1376:
    #####: 1377:								dfc->CompactTable2[i].array[n].DirectFilter[byteIndex] |= bitMask;
        -: 1378:
    #####: 1379:								Add_PID_to_2B_CT(dfc->CompactTable2[i].array[n].CompactTable, temp,	tempPID[m],
        -: 1380:																					DFC_MEMORY_TYPE__CT2);
    #####: 1381:							}
    #####: 1382:						}else{
    #####: 1383:							temp[1] = dfc->dfcMatchList[tempPID[m]]->casepatrn[0];
    #####: 1384:							for(l = 0; l < 256; l++){
    #####: 1385:								temp[0] = l;
        -: 1386:
    #####: 1387:                                fragment_16 = (temp[1] << 8) | temp[0];
    #####: 1388:                                byteIndex = BINDEX(fragment_16);
    #####: 1389:                                bitMask = BMASK(fragment_16);
        -: 1390:
    #####: 1391:								dfc->CompactTable2[i].array[n].DirectFilter[byteIndex] |= bitMask;
        -: 1392:
    #####: 1393:								Add_PID_to_2B_CT(dfc->CompactTable2[i].array[n].CompactTable, temp,	tempPID[m],
        -: 1394:																					DFC_MEMORY_TYPE__CT2);
    #####: 1395:							}
        -: 1396:						}
    #####: 1397:					}
    #####: 1398:				}
        -: 1399:
    #####: 1400:				dfc->CompactTable2[i].array[n].cnt = temp_cnt;
    #####: 1401:				DFC_FREE(tempPID, sizeof(PID_TYPE)*dfc->CompactTable2[i].array[n].cnt, DFC_MEMORY_TYPE__CT2);
    #####: 1402:			}
    #####: 1403:		}
    #####: 1404:	}
        -: 1405:#endif
        -: 1406:	// Only for CT4 firstly
    #####: 1407:	for(i=0; i < CT4_TABLE_SIZE; i++){
    #####: 1408:		for(n=0; n < dfc->CompactTable4[i].cnt; n++){
        -: 1409:			/* If the number of PID is bigger than 3, do recursive filtering */
    #####: 1410:			if(dfc->CompactTable4[i].array[n].cnt >= RECURSIVE_BOUNDARY){
        -: 1411:				/* Initialization */
    #####: 1412:				dfc->CompactTable4[i].array[n].DirectFilter=(uint8_t*)DFC_MALLOC(sizeof(uint8_t)*DF_SIZE_REAL,
        -: 1413:																							DFC_MEMORY_TYPE__CT4);
    #####: 1414:				dfc->CompactTable4[i].array[n].CompactTable=(CT_Type_2_2B*)DFC_MALLOC
        -: 1415:                                                (sizeof(CT_Type_2_2B)*RECURSIVE_CT_SIZE, DFC_MEMORY_TYPE__CT4);
        -: 1416:
    #####: 1417:				if(!dfc->CompactTable4[i].array[n].DirectFilter || !dfc->CompactTable4[i].array[n].CompactTable){
    #####: 1418:					fprintf(stderr, "Failed to allocate memory for recursive things.\n");
    #####: 1419:					return -1;
        -: 1420:				}
        -: 1421:
    #####: 1422:				PID_TYPE *tempPID = (PID_TYPE*)DFC_MALLOC(sizeof(PID_TYPE)*dfc->CompactTable4[i].array[n].cnt,
        -: 1423:																							DFC_MEMORY_TYPE__CT4);	
    #####: 1424:				memcpy(tempPID, dfc->CompactTable4[i].array[n].pid, 
        -: 1425:														sizeof(PID_TYPE) * dfc->CompactTable4[i].array[n].cnt);
        -: 1426:				//free(dfc->CompactTable4[i].array[n].pid);
    #####: 1427:				DFC_FREE(dfc->CompactTable4[i].array[n].pid, dfc->CompactTable4[i].array[n].cnt*sizeof(PID_TYPE),
        -: 1428:															DFC_MEMORY_TYPE__CT4);
    #####: 1429:				dfc->CompactTable4[i].array[n].pid = NULL;
        -: 1430:
    #####: 1431:				int temp_cnt = 0; // cnt for 4 byte patterns.
        -: 1432:
    #####: 1433:				for(m = 0; m < dfc->CompactTable4[i].array[n].cnt; m++){
        -: 1434:					//DFC_PATTERN *mlist = dfc->dfcMatchList[]; 
    #####: 1435:					int pat_len = dfc->dfcMatchList[tempPID[m]]->n - 4;
        -: 1436:
    #####: 1437:					if(pat_len == 0){ /* When pat length is 4 */
    #####: 1438:						temp_cnt ++;
    #####: 1439:						dfc->CompactTable4[i].array[n].pid =
    #####: 1440:							 (PID_TYPE *)realloc(dfc->CompactTable4[i].array[n].pid, sizeof(PID_TYPE)*temp_cnt);
    #####: 1441:						dfc->CompactTable4[i].array[n].pid[temp_cnt-1] = tempPID[m];
    #####: 1442:					}else if (pat_len == 1){ /* When pat length is 5 */
    #####: 1443:						if(dfc->dfcMatchList[tempPID[m]]->nocase){
    #####: 1444:							temp[1] = tolower(dfc->dfcMatchList[tempPID[m]]->patrn[0]);
    #####: 1445:							for(l = 0; l < 256; l++){
    #####: 1446:								temp[0] = l;
        -: 1447:
    #####: 1448:                                fragment_16 = (temp[1] << 8) | temp[0];
    #####: 1449:                                byteIndex = BINDEX(fragment_16);
    #####: 1450:                                bitMask = BMASK(fragment_16);
        -: 1451:
    #####: 1452:								dfc->CompactTable4[i].array[n].DirectFilter[byteIndex] |= bitMask;
        -: 1453:
    #####: 1454:								Add_PID_to_2B_CT(dfc->CompactTable4[i].array[n].CompactTable, temp,	tempPID[m],
        -: 1455:																							DFC_MEMORY_TYPE__CT4);
    #####: 1456:							}
        -: 1457:
    #####: 1458:							temp[1] = toupper(dfc->dfcMatchList[tempPID[m]]->patrn[0]);
    #####: 1459:							for(l = 0; l < 256; l++){
    #####: 1460:								temp[0] = l;
        -: 1461:
    #####: 1462:                                fragment_16 = (temp[1] << 8) | temp[0];
    #####: 1463:                                byteIndex = BINDEX(fragment_16);
    #####: 1464:                                bitMask = BMASK(fragment_16);
        -: 1465:
    #####: 1466:								dfc->CompactTable4[i].array[n].DirectFilter[byteIndex] |= bitMask;
        -: 1467:
    #####: 1468:								Add_PID_to_2B_CT(dfc->CompactTable4[i].array[n].CompactTable, temp,	tempPID[m],
        -: 1469:																							DFC_MEMORY_TYPE__CT4);
    #####: 1470:							}
    #####: 1471:						}else{
    #####: 1472:							temp[1] = dfc->dfcMatchList[tempPID[m]]->casepatrn[0];
    #####: 1473:							for(l = 0; l < 256; l++){
    #####: 1474:								temp[0] = l;
        -: 1475:
    #####: 1476:                                fragment_16 = (temp[1] << 8) | temp[0];
    #####: 1477:                                byteIndex = BINDEX(fragment_16);
    #####: 1478:                                bitMask = BMASK(fragment_16);
        -: 1479:
    #####: 1480:								dfc->CompactTable4[i].array[n].DirectFilter[byteIndex] |= bitMask;
        -: 1481:
    #####: 1482:								Add_PID_to_2B_CT(dfc->CompactTable4[i].array[n].CompactTable, temp,	tempPID[m],
        -: 1483:																						DFC_MEMORY_TYPE__CT4);
    #####: 1484:							}
        -: 1485:						}
        -: 1486:						
    #####: 1487:					}else { /* When pat length is 7 (pat_len is equal to 2(6) or 3(7)) */
    #####: 1488:						if(dfc->dfcMatchList[tempPID[m]]->nocase){
    #####: 1489:							alpha_cnt = 0;
    #####: 1490:							do{
    #####: 1491:								for (l=1, k = 0; l >=0; --l, k++) {
    #####: 1492:									flag[k] =  (alpha_cnt >> l) & 1;
    #####: 1493:								}
        -: 1494:
    #####: 1495:								for (l = pat_len - 2, k = 0; l <= pat_len - 1; l++, k++){
    #####: 1496:									Build_pattern(dfc->dfcMatchList[tempPID[m]], flag, temp, 0,l,k);
    #####: 1497:								}
        -: 1498:
    #####: 1499:                                fragment_16 = (temp[1] << 8) | temp[0];
    #####: 1500:                                byteIndex = BINDEX(fragment_16);
    #####: 1501:                                bitMask = BMASK(fragment_16);
        -: 1502:
    #####: 1503:								dfc->CompactTable4[i].array[n].DirectFilter[byteIndex] |= bitMask;
        -: 1504:
    #####: 1505:								Add_PID_to_2B_CT(dfc->CompactTable4[i].array[n].CompactTable,temp,tempPID[m],
        -: 1506:																						DFC_MEMORY_TYPE__CT4);
        -: 1507:
    #####: 1508:								alpha_cnt++;
    #####: 1509:							}while(alpha_cnt < 4);
    #####: 1510:						}else{ /* case sensitive pattern */
    #####: 1511:							temp[0] = dfc->dfcMatchList[tempPID[m]]->casepatrn[pat_len - 2];
    #####: 1512:							temp[1] = dfc->dfcMatchList[tempPID[m]]->casepatrn[pat_len - 1];
        -: 1513:
    #####: 1514:                            fragment_16 = (temp[1] << 8) | temp[0];
    #####: 1515:                            byteIndex = BINDEX(fragment_16);
    #####: 1516:                            bitMask = BMASK(fragment_16);
        -: 1517:
    #####: 1518:							dfc->CompactTable4[i].array[n].DirectFilter[byteIndex] |= bitMask;
        -: 1519:
    #####: 1520:							Add_PID_to_2B_CT(dfc->CompactTable4[i].array[n].CompactTable,temp,tempPID[m],
        -: 1521:																						 DFC_MEMORY_TYPE__CT4);
        -: 1522:						}
        -: 1523:					}
    #####: 1524:				}
        -: 1525:
    #####: 1526:				dfc->CompactTable4[i].array[n].cnt = temp_cnt;
    #####: 1527:				DFC_FREE(tempPID, sizeof(PID_TYPE)*dfc->CompactTable4[i].array[n].cnt, DFC_MEMORY_TYPE__CT4);
    #####: 1528:			}
    #####: 1529:		}
    #####: 1530:	}
        -: 1531:
        -: 1532:#if 1
        -: 1533:	/* For CT8 */
    #####: 1534:	for(i=0; i < CT8_TABLE_SIZE; i++){
    #####: 1535:		for(n=0; n < dfc->CompactTable8[i].cnt; n++){
        -: 1536:			/* If the number of PID is bigger than RECURSIVE_BOUNDARY, do recursive filtering */
    #####: 1537:			if(dfc->CompactTable8[i].array[n].cnt >= RECURSIVE_BOUNDARY){
        -: 1538:				/* Initialization */
    #####: 1539:				dfc->CompactTable8[i].array[n].DirectFilter
    #####: 1540:                    = (uint8_t*)DFC_MALLOC(DF_SIZE_REAL*sizeof(uint8_t), DFC_MEMORY_TYPE__CT8);
    #####: 1541:				dfc->CompactTable8[i].array[n].CompactTable=(CT_Type_2_2B *)DFC_MALLOC
        -: 1542:                                                (sizeof(CT_Type_2_2B)*RECURSIVE_CT_SIZE,DFC_MEMORY_TYPE__CT8);
        -: 1543:
    #####: 1544:				if(!dfc->CompactTable8[i].array[n].DirectFilter || !dfc->CompactTable8[i].array[n].CompactTable){
    #####: 1545:					fprintf(stderr, "Failed to allocate memory for recursive things.\n");
    #####: 1546:					return -1;
        -: 1547:				}
        -: 1548:
    #####: 1549:				PID_TYPE *tempPID = (PID_TYPE*)DFC_MALLOC(sizeof(PID_TYPE)*dfc->CompactTable8[i].array[n].cnt,
        -: 1550:																						DFC_MEMORY_TYPE__CT8);	
    #####: 1551:				memcpy(tempPID, dfc->CompactTable8[i].array[n].pid, 
        -: 1552:														sizeof(PID_TYPE) * dfc->CompactTable8[i].array[n].cnt);
        -: 1553:				//free(dfc->CompactTable8[i].array[n].pid);
    #####: 1554:				DFC_FREE(dfc->CompactTable8[i].array[n].pid, dfc->CompactTable8[i].array[n].cnt*sizeof(PID_TYPE),
        -: 1555:															DFC_MEMORY_TYPE__CT8);
    #####: 1556:				dfc->CompactTable8[i].array[n].pid = NULL;
        -: 1557:
    #####: 1558:				int temp_cnt = 0; // cnt for 8 byte patterns.
        -: 1559:
    #####: 1560:				for(m = 0; m < dfc->CompactTable8[i].array[n].cnt; m++){
        -: 1561:					//DFC_PATTERN *mlist = dfc->dfcMatchList[]; 
    #####: 1562:					int pat_len = dfc->dfcMatchList[tempPID[m]]->n - 8;
        -: 1563:
    #####: 1564:					if(pat_len == 0){ /* When pat length is 8 */
    #####: 1565:						temp_cnt ++;
    #####: 1566:						dfc->CompactTable8[i].array[n].pid =
    #####: 1567:							 (PID_TYPE *)realloc(dfc->CompactTable8[i].array[n].pid, sizeof(PID_TYPE)*temp_cnt);
    #####: 1568:						dfc->CompactTable8[i].array[n].pid[temp_cnt-1] = tempPID[m];
    #####: 1569:					}else if (pat_len == 1){ /* When pat length is 9 */
    #####: 1570:						if(dfc->dfcMatchList[tempPID[m]]->nocase){
    #####: 1571:							temp[1] = tolower(dfc->dfcMatchList[tempPID[m]]->patrn[0]);
    #####: 1572:							for(l = 0; l < 256; l++){
    #####: 1573:								temp[0] = l;
        -: 1574:
    #####: 1575:                                fragment_16 = (temp[1] << 8) | temp[0];
    #####: 1576:                                byteIndex = BINDEX(fragment_16);
    #####: 1577:                                bitMask = BMASK(fragment_16);
        -: 1578:
    #####: 1579:								dfc->CompactTable8[i].array[n].DirectFilter[byteIndex] |= bitMask;
        -: 1580:
    #####: 1581:								Add_PID_to_2B_CT(dfc->CompactTable8[i].array[n].CompactTable, temp,	tempPID[m],
        -: 1582:																						DFC_MEMORY_TYPE__CT8);
    #####: 1583:							}
        -: 1584:
    #####: 1585:							temp[1] = toupper(dfc->dfcMatchList[tempPID[m]]->patrn[0]);
    #####: 1586:							for(l = 0; l < 256; l++){
    #####: 1587:								temp[0] = l;
        -: 1588:
    #####: 1589:                                fragment_16 = (temp[1] << 8) | temp[0];
    #####: 1590:                                byteIndex = BINDEX(fragment_16);
    #####: 1591:                                bitMask = BMASK(fragment_16);
        -: 1592:
    #####: 1593:								dfc->CompactTable8[i].array[n].DirectFilter[byteIndex] |= bitMask;
        -: 1594:
    #####: 1595:								Add_PID_to_2B_CT(dfc->CompactTable8[i].array[n].CompactTable, temp,	tempPID[m],
        -: 1596:																							DFC_MEMORY_TYPE__CT8);
    #####: 1597:							}
    #####: 1598:						}else{
    #####: 1599:							temp[1] = dfc->dfcMatchList[tempPID[m]]->casepatrn[0];
    #####: 1600:							for(l = 0; l < 256; l++){
    #####: 1601:								temp[0] = l;
        -: 1602:
    #####: 1603:                                fragment_16 = (temp[1] << 8) | temp[0];
    #####: 1604:                                byteIndex = BINDEX(fragment_16);
    #####: 1605:                                bitMask = BMASK(fragment_16);
        -: 1606:
    #####: 1607:								dfc->CompactTable8[i].array[n].DirectFilter[byteIndex] |= bitMask;
        -: 1608:
    #####: 1609:								Add_PID_to_2B_CT(dfc->CompactTable8[i].array[n].CompactTable, temp,	tempPID[m],
        -: 1610:																						DFC_MEMORY_TYPE__CT8);
    #####: 1611:							}
        -: 1612:						}
        -: 1613:						
    #####: 1614:					}else { /* longer than or equal to 10 */
    #####: 1615:						if(dfc->dfcMatchList[tempPID[m]]->nocase){
    #####: 1616:							alpha_cnt = 0;
    #####: 1617:							do{
    #####: 1618:								for (l=1, k = 0; l >=0; --l, k++) {
    #####: 1619:									flag[k] =  (alpha_cnt >> l) & 1;
    #####: 1620:								}
        -: 1621:
    #####: 1622:								for (l = pat_len - 2, k = 0; l <= pat_len - 1; l++, k++){
    #####: 1623:									Build_pattern(dfc->dfcMatchList[tempPID[m]], flag, temp, 0,l,k);
    #####: 1624:								}
        -: 1625:
    #####: 1626:                                fragment_16 = (temp[1] << 8) | temp[0];
    #####: 1627:                                byteIndex = BINDEX(fragment_16);
    #####: 1628:                                bitMask = BMASK(fragment_16);
        -: 1629:
    #####: 1630:								dfc->CompactTable8[i].array[n].DirectFilter[byteIndex] |= bitMask;
        -: 1631:
    #####: 1632:								Add_PID_to_2B_CT(dfc->CompactTable8[i].array[n].CompactTable,temp,tempPID[m],
        -: 1633:																						DFC_MEMORY_TYPE__CT8);
        -: 1634:
    #####: 1635:								alpha_cnt++;
    #####: 1636:							}while(alpha_cnt < 4);
    #####: 1637:						}else{ /* case sensitive pattern */
    #####: 1638:							temp[0] = dfc->dfcMatchList[tempPID[m]]->casepatrn[pat_len - 2];
    #####: 1639:							temp[1] = dfc->dfcMatchList[tempPID[m]]->casepatrn[pat_len - 1];
        -: 1640:
    #####: 1641:                            fragment_16 = (temp[1] << 8) | temp[0];
    #####: 1642:                            byteIndex = BINDEX(fragment_16);
    #####: 1643:                            bitMask = BMASK(fragment_16);
        -: 1644:
    #####: 1645:							dfc->CompactTable8[i].array[n].DirectFilter[byteIndex] |= bitMask;
        -: 1646:
    #####: 1647:							Add_PID_to_2B_CT(dfc->CompactTable8[i].array[n].CompactTable,temp,tempPID[m],
        -: 1648:																							DFC_MEMORY_TYPE__CT8);
        -: 1649:						}
        -: 1650:					}
    #####: 1651:				}
        -: 1652:
    #####: 1653:				dfc->CompactTable8[i].array[n].cnt = temp_cnt;
    #####: 1654:				DFC_FREE(tempPID, sizeof(PID_TYPE)*dfc->CompactTable8[i].array[n].cnt, DFC_MEMORY_TYPE__CT8);
    #####: 1655:			}
    #####: 1656:		}
    #####: 1657:	}
        -: 1658:#endif
        -: 1659:#endif
        -: 1660:
        -: 1661:/* ####################################################################################### */
        -: 1662:
        -: 1663:    //printf("Recursive Initialization is done.\n");
        -: 1664:
        -: 1665:/* ####################################################################################### */
        -: 1666:/* ###############                   Print Information                    ################ */
        -: 1667:/* ####################################################################################### */
        -: 1668:#ifdef PRINT_INFO
        -: 1669:	//DFC_PrintInfo(dfc);
        -: 1670:#endif
        -: 1671:/* ####################################################################################### */
        -: 1672:
    #####: 1673:	return 0;
    #####: 1674:}
        -: 1675:
    #####: 1676:static int Verification_CT1(VERIFI_ARGUMENT)
        -: 1677:{
        -: 1678:	int i;
    #####: 1679:	for(i = 0; i < dfc->CompactTable1[*(buf-2)].cnt; i++){
    #####: 1680:		PID_TYPE pid = dfc->CompactTable1[*(buf-2)].pid[i];
    #####: 1681:		DFC_PATTERN *mlist = dfc->dfcMatchList[pid];
    #####: 1682:        ACTION_FOR_MATCH;
    #####: 1683:	}
    #####: 1684:	return matches;
        -: 1685:}
        -: 1686:
    #####: 1687:static int Verification_CT2(VERIFI_ARGUMENT)
        -: 1688:{
    #####: 1689:	uint32_t crc = _mm_crc32_u16(0, *(uint16_t*)(buf-2));
        -: 1690:
        -: 1691:	// 2. calculate index
    #####: 1692:	crc &= CT2_TABLE_SIZE_MASK;
        -: 1693:
        -: 1694:	BUC_CNT_TYPE i;
    #####: 1695:	for(i = 0; i < dfc->CompactTable2[crc].cnt; i++){
    #####: 1696:		if(dfc->CompactTable2[crc].array[i].pat == *(uint16_t*)(buf-2)){
        -: 1697:			PID_CNT_TYPE j;
    #####: 1698:			if(!dfc->CompactTable2[crc].array[i].DirectFilter){
    #####: 1699:				for(j = 0; j < dfc->CompactTable2[crc].array[i].cnt; j++){
    #####: 1700:					PID_TYPE pid = dfc->CompactTable2[crc].array[i].pid[j];
        -: 1701:					
    #####: 1702:					DFC_PATTERN *mlist = dfc->dfcMatchList[pid];
    #####: 1703:					if(buf - starting_point >= mlist->n){
    #####: 1704:						if(mlist->nocase){
    #####: 1705:							if(!my_strncasecmp(buf-(mlist->n), mlist->casepatrn, mlist->n - 2)){
    #####: 1706:                                ACTION_FOR_MATCH;
    #####: 1707:							}
    #####: 1708:						}else{
    #####: 1709:							if(!my_strncmp(buf-(mlist->n), mlist->casepatrn, mlist->n - 2)){
    #####: 1710:                                ACTION_FOR_MATCH;
    #####: 1711:							}
        -: 1712:						}
    #####: 1713:					}
    #####: 1714:				}
    #####: 1715:			}else{
    #####: 1716:				for(j = 0; j < dfc->CompactTable2[crc].array[i].cnt; j++){
    #####: 1717:                    PID_TYPE pid = dfc->CompactTable2[crc].array[i].pid[j];
    #####: 1718:					DFC_PATTERN *mlist = dfc->dfcMatchList[pid];
    #####: 1719:                    ACTION_FOR_MATCH;
    #####: 1720:				}
    #####: 1721:				DTYPE data = *(uint16_t*)(buf-4);
    #####: 1722:				BTYPE index = BINDEX(data);
    #####: 1723:				BTYPE mask = BMASK(data);	
        -: 1724:
    #####: 1725:				if(dfc->CompactTable2[crc].array[i].DirectFilter[index] & mask) {
    #####: 1726:					uint32_t crc2 = _mm_crc32_u16(0, data);
        -: 1727:
        -: 1728:					// 2. calculate index
    #####: 1729:					crc2 &= CT2_TABLE_SIZE_MASK;
        -: 1730:
        -: 1731:					BUC_CNT_TYPE k;
    #####: 1732:					for(k = 0; k < dfc->CompactTable2[crc].array[i].CompactTable[crc2].cnt; k++){
    #####: 1733:						if(dfc->CompactTable2[crc].array[i].CompactTable[crc2].array[k].pat == data){
        -: 1734:							PID_CNT_TYPE l;
    #####: 1735:							for(l = 0; l < dfc->CompactTable2[crc].array[i].CompactTable[crc2].array[k].cnt; l++){
    #####: 1736:								PID_TYPE pid = dfc->CompactTable2[crc].array[i].CompactTable[crc2].array[k].pid[l];
    #####: 1737:								DFC_PATTERN *mlist = dfc->dfcMatchList[pid];
    #####: 1738:                                ACTION_FOR_MATCH;
    #####: 1739:							}
    #####: 1740:							break;
        -: 1741:						}
    #####: 1742:					}
    #####: 1743:				}
        -: 1744:			}
    #####: 1745:			break;
        -: 1746:		}
    #####: 1747:	}
    #####: 1748:	return matches;
        -: 1749:}
        -: 1750:
        -: 1751:
    #####: 1752:static int Verification_CT4_7(VERIFI_ARGUMENT)
        -: 1753:{
        -: 1754:	// 1. Convert payload to uppercase
    #####: 1755:	unsigned char *temp = buf-2;
        -: 1756:
        -: 1757:	// 2. calculate crc
    #####: 1758:	uint32_t crc = _mm_crc32_u32(0, *(uint32_t*)temp);
        -: 1759:
        -: 1760:	// 3. calculate index
    #####: 1761:	crc &= CT4_TABLE_SIZE_MASK;
        -: 1762:
        -: 1763:	// 4.
        -: 1764:	BUC_CNT_TYPE i;
    #####: 1765:	for(i = 0; i < dfc->CompactTable4[crc].cnt; i++){
    #####: 1766:		if(dfc->CompactTable4[crc].array[i].pat == *(uint32_t*)temp){
        -: 1767:			PID_CNT_TYPE j;
    #####: 1768:			if(!dfc->CompactTable4[crc].array[i].DirectFilter){
    #####: 1769:				for(j = 0; j < dfc->CompactTable4[crc].array[i].cnt; j++){
    #####: 1770:					PID_TYPE pid = dfc->CompactTable4[crc].array[i].pid[j];
        -: 1771:					
    #####: 1772:					DFC_PATTERN *mlist = dfc->dfcMatchList[pid];
    #####: 1773:					if(buf - starting_point >= mlist->n - 2){
    #####: 1774:						if(mlist->nocase){
    #####: 1775:							if(!my_strncasecmp(buf-(mlist->n-2), mlist->casepatrn, mlist->n - 4)){
    #####: 1776:                                ACTION_FOR_MATCH;
    #####: 1777:							}
    #####: 1778:						}else{
    #####: 1779:							if(!my_strncmp(buf-(mlist->n-2), mlist->casepatrn, mlist->n - 4)){
    #####: 1780:                                ACTION_FOR_MATCH;
    #####: 1781:							}
        -: 1782:						}
    #####: 1783:					}
    #####: 1784:				}
    #####: 1785:			}else{
    #####: 1786:				for(j = 0; j < dfc->CompactTable4[crc].array[i].cnt; j++){
    #####: 1787:                    PID_TYPE pid = dfc->CompactTable4[crc].array[i].pid[j];
    #####: 1788:					DFC_PATTERN *mlist = dfc->dfcMatchList[pid];
    #####: 1789:                    ACTION_FOR_MATCH;
    #####: 1790:				}
        -: 1791:
    #####: 1792:				DTYPE data = *(uint16_t*)(buf-4);
    #####: 1793:				BTYPE index = BINDEX(data);
    #####: 1794:				BTYPE mask = BMASK(data);	
        -: 1795:
    #####: 1796:				if(dfc->CompactTable4[crc].array[i].DirectFilter[index] & mask) {
    #####: 1797:					uint32_t crc2 = _mm_crc32_u16(0, data);
        -: 1798:
        -: 1799:					// 2. calculate index
    #####: 1800:					crc2 &= CT2_TABLE_SIZE_MASK;
        -: 1801:
        -: 1802:					BUC_CNT_TYPE k;
    #####: 1803:					for(k = 0; k < dfc->CompactTable4[crc].array[i].CompactTable[crc2].cnt; k++){
    #####: 1804:						if(dfc->CompactTable4[crc].array[i].CompactTable[crc2].array[k].pat == data){
        -: 1805:							PID_CNT_TYPE l;
    #####: 1806:							for(l = 0; l < dfc->CompactTable4[crc].array[i].CompactTable[crc2].array[k].cnt; l++){
    #####: 1807:								PID_TYPE pid = dfc->CompactTable4[crc].array[i].CompactTable[crc2].array[k].pid[l];
        -: 1808:								
    #####: 1809:								DFC_PATTERN *mlist = dfc->dfcMatchList[pid];
    #####: 1810:								if(mlist->nocase){
    #####: 1811:									if(!my_strncasecmp(buf-(mlist->n-2), mlist->casepatrn, mlist->n - 6)){
    #####: 1812:                                        ACTION_FOR_MATCH;
    #####: 1813:									}
    #####: 1814:								}else{
    #####: 1815:									if(!my_strncmp(buf-(mlist->n-2), mlist->casepatrn, mlist->n - 6)){
    #####: 1816:                                        ACTION_FOR_MATCH;
    #####: 1817:									}
        -: 1818:								}
    #####: 1819:							}
    #####: 1820:							break;
        -: 1821:						}
    #####: 1822:					}
    #####: 1823:				}
        -: 1824:			}
    #####: 1825:			break;
        -: 1826:		}
    #####: 1827:	}
    #####: 1828:	return matches;
        -: 1829:}
        -: 1830:
        -: 1831:
        -: 1832:
    #####: 1833:static int Verification_CT8_plus(VERIFI_ARGUMENT)
        -: 1834:{
        -: 1835:	// 1. Convert payload to uppercase
        -: 1836:#ifdef CT8_SWITCH
        -: 1837:	unsigned char temp[8];
    #####: 1838:	ConvertCaseEx (temp, buf-2, 8);
        -: 1839:#else
        -: 1840:	unsigned char *temp = buf-2;
        -: 1841:#endif
        -: 1842:
        -: 1843:	// 2. calculate crc
    #####: 1844:    uint32_t fragment_32 = (temp[7] << 24) | (temp[6] << 16) | (temp[5] << 8) | temp[4];
    #####: 1845:    uint64_t fragment_64 = ((uint64_t)fragment_32 << 32) |
    #####: 1846:                           (temp[3] << 24) | (temp[2] << 16) | (temp[1] << 8) | temp[0];
    #####: 1847:	uint64_t crc = _mm_crc32_u64(0, fragment_64);
        -: 1848:
        -: 1849:	// 3. calculate index
    #####: 1850:	crc &= CT8_TABLE_SIZE_MASK;
        -: 1851:
        -: 1852:	BUC_CNT_TYPE i;
    #####: 1853:	for(i = 0; i < dfc->CompactTable8[crc].cnt; i++){
    #####: 1854:		if(dfc->CompactTable8[crc].array[i].pat == fragment_64){
        -: 1855:			//matches++;	break;
        -: 1856:
        -: 1857:			PID_CNT_TYPE j;
    #####: 1858:			if(!dfc->CompactTable8[crc].array[i].DirectFilter){
    #####: 1859:				for(j = 0; j < dfc->CompactTable8[crc].array[i].cnt; j++){
    #####: 1860:					PID_TYPE pid = dfc->CompactTable8[crc].array[i].pid[j];
        -: 1861:					
    #####: 1862:					DFC_PATTERN *mlist = dfc->dfcMatchList[pid];
    #####: 1863:					int comparison_requirement = min_pattern_interval*(mlist->n-8)/pattern_interval+2;
    #####: 1864:					if(buf - starting_point >= comparison_requirement){
    #####: 1865:						if(mlist->nocase){
    #####: 1866:							if(!my_strncasecmp(buf-comparison_requirement, mlist->casepatrn, mlist->n)){
    #####: 1867:                                ACTION_FOR_MATCH;
    #####: 1868:							}
    #####: 1869:						}else{
    #####: 1870:							if(!my_strncmp(buf-comparison_requirement, mlist->casepatrn, mlist->n)){
    #####: 1871:                                ACTION_FOR_MATCH;
    #####: 1872:							}
        -: 1873:						}
    #####: 1874:					}
    #####: 1875:				}
        -: 1876:#if 1
    #####: 1877:			}else{
    #####: 1878:				for(j = 0; j < dfc->CompactTable8[crc].array[i].cnt; j++){
    #####: 1879:                    PID_TYPE pid = dfc->CompactTable8[crc].array[i].pid[j];
        -: 1880:
    #####: 1881:                    DFC_PATTERN *mlist = dfc->dfcMatchList[pid];
    #####: 1882:					int comparison_requirement = min_pattern_interval*(mlist->n-8)/pattern_interval+2;
    #####: 1883:					if(mlist->nocase){
    #####: 1884:						if(!my_strncasecmp(buf-comparison_requirement, mlist->casepatrn, mlist->n)){
    #####: 1885:                            ACTION_FOR_MATCH;
    #####: 1886:						}
    #####: 1887:					}else{
    #####: 1888:						if(!my_strncmp(buf-comparison_requirement, mlist->casepatrn, mlist->n)){
    #####: 1889:                            ACTION_FOR_MATCH;
    #####: 1890:						}
        -: 1891:					}
    #####: 1892:				}
        -: 1893:
    #####: 1894:				DTYPE data = *(uint16_t*)(buf-4);
    #####: 1895:				BTYPE index = BINDEX(data);
    #####: 1896:				BTYPE mask = BMASK(data);	
        -: 1897:
    #####: 1898:				if(dfc->CompactTable8[crc].array[i].DirectFilter[index] & mask) {
    #####: 1899:					uint32_t crc2 = _mm_crc32_u16(0, data);
        -: 1900:
        -: 1901:					// 2. calculate index
    #####: 1902:					crc2 &= CT2_TABLE_SIZE_MASK;
        -: 1903:
        -: 1904:					BUC_CNT_TYPE k;
    #####: 1905:					for(k = 0; k < dfc->CompactTable8[crc].array[i].CompactTable[crc2].cnt; k++){
    #####: 1906:						if(dfc->CompactTable8[crc].array[i].CompactTable[crc2].array[k].pat == data){
        -: 1907:							PID_CNT_TYPE l;
    #####: 1908:							for(l = 0; l < dfc->CompactTable8[crc].array[i].CompactTable[crc2].array[k].cnt; l++){
    #####: 1909:								PID_TYPE pid = dfc->CompactTable8[crc].array[i].CompactTable[crc2].array[k].pid[l];
        -: 1910:								
    #####: 1911:								DFC_PATTERN *mlist = dfc->dfcMatchList[pid];
    #####: 1912:								int comparison_requirement = min_pattern_interval*(mlist->n-8)/pattern_interval+2;
    #####: 1913:								if(buf - starting_point >= comparison_requirement){
    #####: 1914:									if(mlist->nocase){
    #####: 1915:										if(!my_strncasecmp(buf-comparison_requirement, mlist->casepatrn,
    #####: 1916:																					 mlist->n)){
    #####: 1917:                                            ACTION_FOR_MATCH;
    #####: 1918:										}
    #####: 1919:									}else{
    #####: 1920:										if(!my_strncmp(buf-comparison_requirement, mlist->casepatrn,
    #####: 1921:																					 mlist->n)){
    #####: 1922:                                            ACTION_FOR_MATCH;
    #####: 1923:										}
        -: 1924:									}
        -: 1925:
    #####: 1926:								}
    #####: 1927:							}
    #####: 1928:							break;
        -: 1929:						}
    #####: 1930:					}
    #####: 1931:				}
        -: 1932:			}
        -: 1933:#endif
    #####: 1934:			break;
        -: 1935:		}
    #####: 1936:	}
        -: 1937:
    #####: 1938:	return matches;
        -: 1939:}
        -: 1940:
        -: 1941:
    #####: 1942:static inline int Progressive_Filtering(PROGRE_ARGUMENT) 
        -: 1943:{
        -: 1944:#ifdef ENABLE_PROGRESSIVE_FILTERING
    #####: 1945:    if(dfc->cDF0[*(buf-2)]){
    #####: 1946:		matches = Verification_CT1(VERIFI_PARAMETER);
    #####: 1947:	}
        -: 1948:
    #####: 1949:    if (unlikely(dfc->cDF1[idx] & msk)) {
    #####: 1950:		matches = Verification_CT2(VERIFI_PARAMETER);
    #####: 1951:	}
        -: 1952:
    #####: 1953:    if(rest_len >= 4){
    #####: 1954:        DTYPE data = *(uint16_t*)(buf);
    #####: 1955:        BTYPE index = BINDEX(data);
    #####: 1956:        BTYPE mask = BMASK(data);	
        -: 1957:
    #####: 1958:        if (unlikely((mask & dfc->ADD_DF_4_plus[index]))) {
    #####: 1959:            if (unlikely(mask & dfc->ADD_DF_4_1[index])) {
        -: 1960:                //if (unlikely(msk & dfc->cDF2[idx])) {
    #####: 1961:                    matches = Verification_CT4_7(VERIFI_PARAMETER);
        -: 1962:                    //matches ++;
        -: 1963:                //}
    #####: 1964:            }
        -: 1965:
    #####: 1966:            DTYPE data8 = *(uint16_t*)(&buf[4]);
    #####: 1967:            BTYPE index8 = BINDEX(data8);
    #####: 1968:            BTYPE mask8 = BMASK(data8);
        -: 1969:
    #####: 1970:            if (unlikely(mask8 & dfc->ADD_DF_8_1[index8])) {
    #####: 1971:                data8 = *(uint16_t*)(&buf[2]);
    #####: 1972:                index8 = BINDEX(data8);
    #####: 1973:                mask8 = BMASK(data8);
    #####: 1974:                if (unlikely(mask8 & dfc->ADD_DF_8_2[index8])) {
    #####: 1975:                    if ((rest_len >= 8)) {
    #####: 1976:                        matches = Verification_CT8_plus(VERIFI_PARAMETER);
        -: 1977:                        //matches ++;
    #####: 1978:                    }
    #####: 1979:                }
    #####: 1980:            }
    #####: 1981:        }
    #####: 1982:    }
        -: 1983:#else
        -: 1984:	matches = Verification_CT1(VERIFI_PARAMETER);
        -: 1985:	matches = Verification_CT2(VERIFI_PARAMETER);
        -: 1986:	matches = Verification_CT4_7(VERIFI_PARAMETER);
        -: 1987:	matches = Verification_CT8_plus(VERIFI_PARAMETER);
        -: 1988:#endif
        -: 1989:
    #####: 1990:    return matches;
        -: 1991:}
        -: 1992:
    #####: 1993:int DFC_Search(SEARCH_ARGUMENT)
        -: 1994:{
        -: 1995:	int i;
    #####: 1996:    int matches = 0;
        -: 1997:
    #####: 1998:	if (unlikely(buflen <= 0))
    #####: 1999:        return 0;
        -: 2000:
    #####: 2001:	uint8_t *DirectFilter1 = dfc->DirectFilter1;
        -: 2002:
    #####: 2003:	for (i = 0; i < buflen - 1; i++) {
    #####: 2004:		DTYPE data = *(uint16_t*)(&buf[i]);
    #####: 2005:		BTYPE index = BINDEX(data);
    #####: 2006:		BTYPE mask = BMASK(data);
        -: 2007:
    #####: 2008:		if (unlikely(DirectFilter1[index] & mask)) {
    #####: 2009:			matches = Progressive_Filtering(PROGRE_PARAMETER);
    #####: 2010:		}
    #####: 2011:	} 
        -: 2012:
        -: 2013:	/* It is needed to check last 1 byte from payload */
    #####: 2014:    if(dfc->cDF0[buf[buflen-1]]){
        -: 2015:        int i;
    #####: 2016:        for(i = 0; i < dfc->CompactTable1[buf[buflen-1]].cnt; i++){
    #####: 2017:            PID_TYPE pid = dfc->CompactTable1[buf[buflen-1]].pid[i];
    #####: 2018:			DFC_PATTERN *mlist = dfc->dfcMatchList[pid];
    #####: 2019:            ACTION_FOR_MATCH;
    #####: 2020:        }
    #####: 2021:    }
        -: 2022:
    #####: 2023:	return matches;
    #####: 2024:}
        -: 2025:
        -: 2026:
        -: 2027:/*************************************************************************************/
        -: 2028:/*                                       Utility                                     */
        -: 2029:/*************************************************************************************/
    #####: 2030:static float my_sqrtf(float input, float x)
        -: 2031:{
        -: 2032:    int i;
    #####: 2033:	if( x == 0 && input == 0)
    #####: 2034:		return 0;
    #####: 2035:    for(i = 0; i < 10; i++){
    #####: 2036:        x = (x + (input / x))/2;
    #####: 2037:    }
    #####: 2038:    return x;
    #####: 2039:}
        -: 2040:
    #####: 2041:static void init_xlatcase()
        -: 2042:{
        -: 2043:	int i;
    #####: 2044:	for (i = 0; i < 256; i++)
    #####: 2045:		xlatcase[i] = (unsigned char)toupper(i);
    #####: 2046:}
        -: 2047:
    #####: 2048:static inline void ConvertCaseEx (unsigned char *d, unsigned char *s, int m)
        -: 2049:{
        -: 2050:	int i;
        -: 2051:
    #####: 2052:	for (i=0; i < m; i++)
    #####: 2053:		d[i] = xlatcase[ s[i] ];
    #####: 2054:}
        -: 2055:
    #####: 2056:static inline int my_strncmp(unsigned char *a, unsigned char *b, int n){
        -: 2057:    int i;
    #####: 2058:    for(i = 0; i < n ; i++){
    #####: 2059:        if(a[i] != b[i])
    #####: 2060:            return -1;
    #####: 2061:    }
    #####: 2062:    return 0;
    #####: 2063:}
        -: 2064:
    #####: 2065:static inline int my_strncasecmp(unsigned char *a, unsigned char *b, int n){
        -: 2066:    int i;
    #####: 2067:    for(i = 0; i < n ; i++){
    #####: 2068:        if(tolower(a[i]) != tolower(b[i]))
    #####: 2069:            return -1;
    #####: 2070:    }
    #####: 2071:    return 0;
    #####: 2072:}
        -: 2073:
    #####: 2074:static void * DFC_REALLOC(void *p, uint16_t n, dfcDataType type, dfcMemoryType type2 )
        -: 2075:{
    #####: 2076:	switch(type){
        -: 2077:		case DFC_PID_TYPE:
    #####: 2078:			p = realloc((PID_TYPE*)p, sizeof(PID_TYPE)*n);
    #####: 2079:			dfc_total_memory += sizeof(PID_TYPE);
    #####: 2080:			switch(type2){
        -: 2081:                case DFC_MEMORY_TYPE__PATTERN:
    #####: 2082:                    dfc_pattern_memory += sizeof(PID_TYPE);
    #####: 2083:                    break;
        -: 2084:				case DFC_MEMORY_TYPE__CT2:
    #####: 2085:					dfc_memory_ct2 += sizeof(PID_TYPE);
    #####: 2086:					break;
        -: 2087:				case DFC_MEMORY_TYPE__CT3:
    #####: 2088:					dfc_memory_ct3 += sizeof(PID_TYPE);
    #####: 2089:					break;
        -: 2090:				case DFC_MEMORY_TYPE__CT4:
    #####: 2091:					dfc_memory_ct4 += sizeof(PID_TYPE);
    #####: 2092:					break;
        -: 2093:				case DFC_MEMORY_TYPE__CT8:
    #####: 2094:					dfc_memory_ct8 += sizeof(PID_TYPE);
    #####: 2095:					break;
        -: 2096:				default:
    #####: 2097:					break;
        -: 2098:			}
    #####: 2099:			return p;
        -: 2100:		case DFC_CT_Type_2_Array:
    #####: 2101:			p = realloc((CT_Type_2_Array*)p, sizeof(CT_Type_2_Array)*n);
    #####: 2102:			dfc_total_memory += sizeof(CT_Type_2_Array);
    #####: 2103:			switch(type2){
        -: 2104:				case DFC_MEMORY_TYPE__CT2:
    #####: 2105:					dfc_memory_ct2 += sizeof(CT_Type_2_Array);
    #####: 2106:					break;
        -: 2107:				case DFC_MEMORY_TYPE__CT3:
    #####: 2108:					dfc_memory_ct3 += sizeof(CT_Type_2_Array);
    #####: 2109:					break;
        -: 2110:				case DFC_MEMORY_TYPE__CT4:
    #####: 2111:					dfc_memory_ct4 += sizeof(CT_Type_2_Array);
    #####: 2112:					break;
        -: 2113:				case DFC_MEMORY_TYPE__CT8:
    #####: 2114:					dfc_memory_ct8 += sizeof(CT_Type_2_Array);
    #####: 2115:					break;
        -: 2116:				default:
    #####: 2117:					break;
        -: 2118:			}
    #####: 2119:			return p;
        -: 2120:		case DFC_CT_Type_2_2B_Array:
    #####: 2121:			p = realloc((CT_Type_2_2B_Array*)p, sizeof(CT_Type_2_2B_Array)*n);
    #####: 2122:			dfc_total_memory += sizeof(CT_Type_2_2B_Array);
    #####: 2123:			switch(type2){
        -: 2124:				case DFC_MEMORY_TYPE__CT2:
    #####: 2125:					dfc_memory_ct2 += sizeof(CT_Type_2_2B_Array);
    #####: 2126:					break;
        -: 2127:				case DFC_MEMORY_TYPE__CT3:
    #####: 2128:					dfc_memory_ct3 += sizeof(CT_Type_2_2B_Array);
    #####: 2129:					break;
        -: 2130:				case DFC_MEMORY_TYPE__CT4:
    #####: 2131:					dfc_memory_ct4 += sizeof(CT_Type_2_2B_Array);
    #####: 2132:					break;
        -: 2133:				case DFC_MEMORY_TYPE__CT8:
    #####: 2134:					dfc_memory_ct8 += sizeof(CT_Type_2_2B_Array);
    #####: 2135:					break;
        -: 2136:				default:
    #####: 2137:					break;
        -: 2138:			}
    #####: 2139:			return p;
        -: 2140:		case DFC_CT_Type_2_8B_Array:
    #####: 2141:			p = realloc((CT_Type_2_8B_Array*)p, sizeof(CT_Type_2_8B_Array)*n);
    #####: 2142:			dfc_total_memory += sizeof(CT_Type_2_8B_Array);
    #####: 2143:			switch(type2){
        -: 2144:				case DFC_MEMORY_TYPE__CT2:
    #####: 2145:					dfc_memory_ct2 += sizeof(CT_Type_2_8B_Array);
    #####: 2146:					break;
        -: 2147:				case DFC_MEMORY_TYPE__CT3:
    #####: 2148:					dfc_memory_ct3 += sizeof(CT_Type_2_8B_Array);
    #####: 2149:					break;
        -: 2150:				case DFC_MEMORY_TYPE__CT4:
    #####: 2151:					dfc_memory_ct4 += sizeof(CT_Type_2_8B_Array);
    #####: 2152:					break;
        -: 2153:				case DFC_MEMORY_TYPE__CT8:
    #####: 2154:					dfc_memory_ct8 += sizeof(CT_Type_2_8B_Array);
    #####: 2155:					break;
        -: 2156:				default:
    #####: 2157:					break;
        -: 2158:			}
    #####: 2159:			return p;
        -: 2160:		default:
    #####: 2161:			printf("ERROR! Data Type is not correct!\n");
    #####: 2162:			break;
        -: 2163:	}
    #####: 2164:	return NULL;
    #####: 2165:}
        -: 2166:
    #####: 2167:static void DFC_FREE(void *p, int n, dfcMemoryType type){
    #####: 2168:	free(p);
    #####: 2169:	switch (type)
        -: 2170:	{
        -: 2171:		case DFC_MEMORY_TYPE__DFC:
    #####: 2172:			break;
        -: 2173:		case DFC_MEMORY_TYPE__PATTERN:
    #####: 2174:			dfc_pattern_memory -= n;
    #####: 2175:			break;
        -: 2176:		case DFC_MEMORY_TYPE__CT2:
    #####: 2177:			dfc_memory_ct2 -= n;
    #####: 2178:			break;
        -: 2179:		case DFC_MEMORY_TYPE__CT3:
    #####: 2180:			dfc_memory_ct3 -= n;
    #####: 2181:			break;
        -: 2182:		case DFC_MEMORY_TYPE__CT4:
    #####: 2183:			dfc_memory_ct4 -= n;
    #####: 2184:			break;
        -: 2185:		case DFC_MEMORY_TYPE__CT8:
    #####: 2186:			dfc_memory_ct8 -= n;
    #####: 2187:			break;
        -: 2188:		case DFC_MEMORY_TYPE__NONE:
    #####: 2189:			break;
        -: 2190:		default:
        -: 2191:			//printf("%s(%d) Invalid memory type\n", __FILE__, __LINE__);
    #####: 2192:			break;
        -: 2193:	}
    #####: 2194:	dfc_total_memory -= n;
    #####: 2195:}
        -: 2196:
    #####: 2197:static void * DFC_MALLOC(int n, dfcMemoryType type )
        -: 2198:{
    #####: 2199:    void *p = calloc(1, n); // initialize it to 0
        -: 2200:
    #####: 2201:    if (p != NULL)
        -: 2202:    {
    #####: 2203:        switch (type)
        -: 2204:        {
        -: 2205:            case DFC_MEMORY_TYPE__DFC:
    #####: 2206:                break;
        -: 2207:            case DFC_MEMORY_TYPE__PATTERN:
    #####: 2208:				dfc_pattern_memory += n;
    #####: 2209:                break;
        -: 2210:            case DFC_MEMORY_TYPE__CT2:
    #####: 2211:				dfc_memory_ct2 += n;
    #####: 2212:                break;
        -: 2213:            case DFC_MEMORY_TYPE__CT3:
    #####: 2214:				dfc_memory_ct3 += n;
    #####: 2215:                break;
        -: 2216:            case DFC_MEMORY_TYPE__CT4:
    #####: 2217:				dfc_memory_ct4 += n;
    #####: 2218:                break;
        -: 2219:            case DFC_MEMORY_TYPE__CT8:
    #####: 2220:				dfc_memory_ct8 += n;
    #####: 2221:                break;
        -: 2222:            case DFC_MEMORY_TYPE__NONE:
    #####: 2223:                break;
        -: 2224:            default:
    #####: 2225:                printf("%s(%d) Invalid memory type\n", __FILE__, __LINE__);
    #####: 2226:                break;
        -: 2227:        }
    #####: 2228:        dfc_total_memory += n;
    #####: 2229:    }
    #####: 2230:    return p;
        -: 2231:}
        -: 2232:
    #####: 2233:static void Build_pattern(DFC_PATTERN *p, uint8_t *flag, uint8_t *temp, uint32_t i, int j, int k){
    #####: 2234:    if(p->nocase){
    #####: 2235:        if((p->patrn[j] >= 65 && p->patrn[j]<=90) ||
    #####: 2236:            (p->patrn[j] >= 97 && p->patrn[j]<=122)) {
    #####: 2237:            if(flag[k] == 0)
    #####: 2238:                temp[k] = tolower(p->patrn[j]);
        -: 2239:            else
    #####: 2240:                temp[k] = toupper(p->patrn[j]);
    #####: 2241:        } else {
    #####: 2242:            temp[k] = p->patrn[j];
        -: 2243:        }
    #####: 2244:    }else{
    #####: 2245:        temp[k] = p->casepatrn[j]; // original pattern
        -: 2246:    }
    #####: 2247:    return ;
        -: 2248:}
        -: 2249:
        -: 2250:/**
        -: 2251: * \internal
        -: 2252: * \brief Creates a hash of the pattern.  We use it for the hashing process
        -: 2253: *        during the initial pattern insertion time, to cull duplicate sigs.
        -: 2254: *
        -: 2255: * \param pat    Pointer to the pattern.
        -: 2256: * \param patlen Pattern length.
        -: 2257: *
        -: 2258: * \retval hash A 32 bit unsigned hash.
        -: 2259: */
    #####: 2260:static inline uint32_t DFC_InitHashRaw(uint8_t *pat, uint16_t patlen, int nocase)
        -: 2261:{
    #####: 2262:    uint32_t hash  = 0;
        -: 2263:    int i;
    #####: 2264:    for (i = 0; i < patlen; i++)
    #####: 2265:        hash+= pat[i];
        -: 2266:
    #####: 2267:    hash += nocase;
        -: 2268:
    #####: 2269:    return (hash % INIT_HASH_SIZE);
        -: 2270:}
        -: 2271:
        -: 2272:
        -: 2273:/**
        -: 2274: * \internal
        -: 2275: * \brief Looks up a pattern.  We use it for the hashing process during the
        -: 2276: *        the initial pattern insertion time, to cull duplicate sigs.
        -: 2277: *
        -: 2278: * \param ctx    Pointer to the DFC structure.
        -: 2279: * \param pat    Pointer to the pattern.
        -: 2280: * \param patlen Pattern length.
        -: 2281: * \param nocase Pattern case insensitivity
        -: 2282: *
        -: 2283: */
    #####: 2284:static inline DFC_PATTERN *DFC_InitHashLookup(DFC_STRUCTURE *ctx, uint8_t *pat,
        -: 2285:                                              uint16_t patlen, int nocase)
        -: 2286:{
    #####: 2287:    uint32_t hash = DFC_InitHashRaw(pat, patlen, nocase);
        -: 2288:
    #####: 2289:    if (ctx->init_hash == NULL) {
    #####: 2290:        return NULL;
        -: 2291:    }
        -: 2292:
    #####: 2293:    DFC_PATTERN *t = ctx->init_hash[hash];
    #####: 2294:    for ( ; t != NULL; t = t->next) {
    #####: 2295:        if (!strcmp((char*)t->casepatrn, (char*)pat))
    #####: 2296:            return t;
    #####: 2297:    }
        -: 2298:
    #####: 2299:    return NULL;
    #####: 2300:}
        -: 2301:
    #####: 2302:static inline int DFC_InitHashAdd(DFC_STRUCTURE *ctx, DFC_PATTERN *p)
        -: 2303:{
    #####: 2304:    uint32_t hash = DFC_InitHashRaw(p->casepatrn, p->n, p->nocase);
        -: 2305:
    #####: 2306:    if (ctx->init_hash == NULL) {
    #####: 2307:        return 0;
        -: 2308:    }
        -: 2309:
    #####: 2310:    if (ctx->init_hash[hash] == NULL) {
    #####: 2311:        ctx->init_hash[hash] = p;
    #####: 2312:        return 0;
        -: 2313:    }
        -: 2314:
    #####: 2315:    DFC_PATTERN *tt = NULL;
    #####: 2316:    DFC_PATTERN *t = ctx->init_hash[hash];
        -: 2317:
        -: 2318:    /* get the list tail */
    #####: 2319:    do {
    #####: 2320:        tt = t;
    #####: 2321:        t = t->next;
    #####: 2322:    } while (t != NULL);
        -: 2323:
    #####: 2324:    tt->next = p;
        -: 2325:
    #####: 2326:    return 0;
    #####: 2327:}
        -: 2328:
        -: 2329:/*************************************************************************************/
        -: 2330://}
        -: 2331://#endif
